[{"title":"Leetcode 2020-03月份每日一题","url":"/posts/20-03-leetcode.html","content":"\n 1-10\n 01 225. 用队列实现栈\n 题目\n使用队列实现栈的下列操作：\n\n\npush(x) – 元素 x 入栈\n\n\npop() – 移除栈顶元素\n\n\ntop() – 获取栈顶元素\n\n\nempty() – 返回栈是否为空\n注意:\n\n\n你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。\n\n\n你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\n\n\n你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。\n\n\n 思路\n没啥好说的，就是一个队列存数据，一个队列辅助入栈，入栈时交换两个队列。\n code\nclass MyStack &#123;    private Queue&lt;Integer&gt; queue1,queue2;        /** Initialize your data structure here. */    public MyStack() &#123;        queue1=new ArrayDeque&lt;&gt;();        queue2=new ArrayDeque&lt;&gt;();    &#125;    /** Push element x onto stack. */    public void push(int x) &#123;        queue1.add(x);        while (!queue2.isEmpty())queue1.add(queue2.poll());        Queue tmp=queue1;queue1=queue2;queue2=tmp;    &#125;    /** Removes the element on top of the stack and returns that element. */    public int pop() &#123;        return queue2.poll();    &#125;    /** Get the top element. */    public int top() &#123;        return queue2.peek();    &#125;    /** Returns whether the stack is empty. */    public boolean empty() &#123;        return queue2.isEmpty();    &#125;&#125;\n 02 206. 反转链表\n 题目\n反转一个单链表。\n示例:\n\n输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL\n输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL\n\n进阶:\n你可以迭代或递归地反转链表。你能否用两种方法解决这道题？\n 思路\n老题目了，上数据结构的时候就说过，遍历链表，遍历到结点链接到上一个节点并记录该结点。\n code\nclass Solution &#123;    public ListNode reverseList(ListNode head) &#123;        if (head==null||head.next==null)return head;        ListNode last=null;        ListNode cur=head;        ListNode next=null;        while (cur!=null)&#123;            next=cur.next;            cur.next=last;            last=cur;            cur=next;        &#125;        return last;    &#125;&#125;\n 03 面试题 10.01. 合并排序的数组\n 题目\n给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。\n初始化 A 和 B 的元素数量分别为 m 和 n。\n示例:\n\n输入:\nA = [1,2,3,0,0,0], m = 3\nB = [2,5,6],       n = 3\n输出: [1,2,2,3,5,6]\n\n说明:\n\nA.length == n + m\n\n 思路\n双指针。\n code\nclass Solution &#123;    public void merge(int[] A, int m, int[] B, int n) &#123;        int i=A.length-1;        m-=1;n-=1;        while (m&gt;=0&amp;&amp;n&gt;=0)&#123;            if (A[m]&gt;B[n])&#123;                A[i--]=A[m];m--;            &#125;else &#123;                A[i--]=B[n];n--;            &#125;        &#125;        while (n&gt;=0)&#123;            A[i--]=B[n];n--;        &#125;    &#125;&#125;\n 04 994. 腐烂的橘子\n 题目\n在给定的网格中，每个单元格可以有以下三个值之一：\n\n值 0 代表空单元格；\n值 1 代表新鲜橘子；\n值 2 代表腐烂的橘子。\n每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。\n\n返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。\n示例 1：\n\n输入：[[2,1,1],[1,1,0],[0,1,1]]输出：4\n示例 2：\n输入：[[2,1,1],[0,1,1],[1,0,1]]输出：-1解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。\n示例 3：\n输入：[[0,2]]输出：0解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。\n提示：\n\n1 &lt;= grid.length &lt;= 10\n1 &lt;= grid[0].length &lt;= 10\ngrid[i][j] 仅为 0、1 或 2\n\n 思路\n模拟一遍这个过程，但是每次烂掉的橘子记为-1，之后再统一标记为2，避免一次中的腐烂传播。\n code\nclass Solution &#123;    public int orangesRotting(int[][] grid) &#123;        int count =0;        while(lan(grid))&#123;            count++;        &#125;        for (int[] ints : grid) &#123;            for (int j = 0; j &lt; grid[0].length; j++) &#123;                if (ints[j] == 1) &#123;                    return -1;                &#125;            &#125;        &#125;        return count;    &#125;    public static boolean lan(int [][] grid)&#123;        boolean lan=false;        for(int i=0;i&lt;=grid.length-1;i++)&#123;            for (int j = 0; j &lt; grid[0].length; j++) &#123;                if(grid[i][j]==2)&#123;                    if(i-1&gt;=0&amp;&amp;grid[i-1][j]==1)&#123;                        grid[i-1][j]=-1;                        lan=true;                    &#125;                    if(i+1&lt;grid.length&amp;&amp;grid[i+1][j]==1)&#123;                        grid[i+1][j]=-1;                        lan=true;                    &#125;                    if(j-1&gt;=0&amp;&amp;grid[i][j-1]==1)&#123;                        grid[i][j-1]=-1;                        lan=true;                    &#125;                    if(j+1&lt;grid[0].length&amp;&amp;grid[i][j+1]==1)&#123;                        grid[i][j+1]=-1;                        lan=true;                    &#125;                &#125;            &#125;        &#125;        for(int i=0;i&lt;=grid.length-1;i++)&#123;            for (int j = 0; j &lt; grid[0].length; j++) &#123;                if(grid[i][j]==-1)&#123;                    grid[i][j]=2;                &#125;            &#125;        &#125;        return lan;    &#125;&#125;\n 05 1103. 分糖果 II\n 题目\n排排坐，分糖果。\n我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people个小朋友。\n给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。\n然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。\n重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。\n返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第i 个小朋友分到的糖果数）。\n示例 1：\n输入：candies = 7, num_people = 4输出：[1,2,3,1]解释：第一次，ans[0] += 1，数组变为 [1,0,0,0]。第二次，ans[1] += 2，数组变为 [1,2,0,0]。第三次，ans[2] += 3，数组变为 [1,2,3,0]。第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。\n示例 2：\n输入：candies = 10, num_people = 3输出：[5,2,3]解释：第一次，ans[0] += 1，数组变为 [1,0,0]。第二次，ans[1] += 2，数组变为 [1,2,0]。第三次，ans[2] += 3，数组变为 [1,2,3]。第四次，ans[0] += 4，最终数组变为 [5,2,3]。\n提示：\n\n1 &lt;= candies &lt;= 10^9\n1 &lt;= num_people &lt;= 1000\n\n 思路\n纯数学计算，先计算出把所有小朋友发全可以发多少次，然后剩下的糖果模拟发完为止。\n code\nclass Solution &#123;    public int[] distributeCandies(int candies, int num_people) &#123;        int[] res=new int[num_people];        int tmp=candies;        int count=-1;        while (tmp&gt;0)&#123;            candies=tmp;++count;            tmp-=num_people*((2*count+1)*num_people+1)/2;        &#125;        for (int i = 0; i &lt; num_people; i++) &#123;            res[i]=count*(2*(i+1)+(count-1)*num_people)/2;            tmp=count*num_people+i+1;            if (candies&lt;=0)continue;            if (candies&gt;=tmp)&#123;                res[i]+=tmp;                candies-=tmp;            &#125;else &#123;                res[i]+=candies;                candies=0;            &#125;        &#125;        return res;    &#125;&#125;\n 06 面试题57 - II. 和为s的连续正数序列\n 题目\n输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。\n序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。\n示例 1：\n\n输入：target = 9\n输出：[[2,3,4],[4,5]]\n\n示例 2：\n\n输入：target = 15\n输出：[[1,2,3,4,5],[4,5,6],[7,8]]\n\n限制：\n\n1 &lt;= target &lt;= 10^5\n\n 思路\n滑动窗口，因为都是正数，要往目标和靠近，小的时候右边界右移，大的时候左边界右移。\n code\nclass Solution:    def findContinuousSequence(self, target: int) -&gt; List[List[int]]:        i = 1  # 滑动窗口的左边界        j = 1  # 滑动窗口的右边界        sum = 0  # 滑动窗口中数字的和        res = []        while i &lt;= target // 2:            if sum &lt; target:                sum += j                j += 1            elif sum &gt; target:                sum -= i                i += 1            else:                arr = list(range(i, j))                res.append(arr)                sum -= i                i += 1        return res\n 07 面试题59 - II. 队列的最大值\n 题目\n请定义一个队列并实现函数max_value得到队列里的最大值，要求函数max_value、push_back 和 pop_front的均摊时间复杂度都是O(1)。\n若队列为空，pop_front和 max_value需要返回 -1\n示例 1：\n\n输入:\n[&quot;MaxQueue&quot;,“push_back”,“push_back”,“max_value”,“pop_front”,“max_value”]\n[[],[1],[2],[],[],[]]\n输出: [null,null,null,2,1,2]\n\n示例 2：\n\n输入:\n[&quot;MaxQueue&quot;,“pop_front”,“max_value”]\n[[],[],[]]\n输出: [null,-1,-1]\n\n限制：\n\n1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000\n1 &lt;= value &lt;= 10^5\n\n 思路\n当一个元素进入队列的时候，它前面所有比它小的元素就不会再对答案产生影响。所以我们只需要维护一个单调队列即可，在放入元素的时候，将单调队列里所有比该元素小的值poll，输出元素的时候，如果这个元素是当时的最大值，则将单调队列也进行poll。\n code\nclass MaxQueue &#123;    private Queue&lt;Integer&gt; queue;        private Deque&lt;Integer&gt; max;        public MaxQueue() &#123;            queue=new LinkedList&lt;&gt;();            max=new LinkedList&lt;&gt;();        &#125;        public int max_value() &#123;            if (max.isEmpty())return -1;            return max.getFirst();        &#125;        public void push_back(int value) &#123;            queue.add(value);            while (!max.isEmpty()&amp;&amp;max.getLast()&lt;value)max.pollLast();            max.add(value);        &#125;        public int pop_front() &#123;            if (queue.isEmpty())return -1;            int value=queue.poll();            if (max.getFirst()==value)max.pollFirst();            return value;        &#125;&#125;\n 08 322. 零钱兑换\n 题目\n给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。\n示例 1:\n输入: coins = [1, 2, 5], amount = 11输出: 3 解释: 11 = 5 + 5 + 1\n示例 2:\n输入: coins = [2], amount = 3输出: -1\n说明:\n你可以认为每种硬币的数量是无限的。\n 思路\n动态规划，属于背包问题。dp[i][j]记录当只用前i种硬币组合j时的最少硬币个数，则有dp[i][j]=min⁡(dp[i−1][j],dp[i][j−coins[i]]+1)dp[i][j]=\\min(dp[i-1][j],dp[i][j-coins[i]]+1)dp[i][j]=min(dp[i−1][j],dp[i][j−coins[i]]+1).如果dp[i][j-coins[i]]存在的话。因为只使用了上一次的状态，所以可以用滚动数组进行优化。\n code\nclass Solution &#123;    public int coinChange(int[] coins, int amount) &#123;        int len=coins.length;        int[] dp=new int[amount+1];        dp[0]=0;        for (int i=1;i&lt;amount+1;i++)&#123;            dp[i]=Integer.MAX_VALUE/2;        &#125;        for (int i=0;i&lt;len;i++)&#123;            for (int j=coins[i];j&lt;amount+1;j++)&#123;                dp[j]=Integer.min(dp[j],dp[j-coins[i]]+1);            &#125;        &#125;        if (dp[amount]&gt;=amount+1)&#123;            return -1;        &#125;        return dp[amount];    &#125;&#125;\n 09 121. 买卖股票的最佳时机\n 题目\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。\n注意：你不能在买入股票前卖出股票。\n示例 1:\n\n输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n\n示例 2:\n\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n 思路\n从前往后遍历，记录当前最小值与当前值减去最小值的差的最大值。\n code\nclass Solution &#123;    public int maxProfit(int[] prices) &#123;        int res=0;        int min=Integer.MAX_VALUE;        for (int price : prices) &#123;            min=Math.min(min,price);            res=Math.max(res,price-min);        &#125;        return res;    &#125;&#125;\n 10 543. 二叉树的直径\n 题目\n给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。\n示例 :\n给定二叉树\n      1\n     / \\\n    2   3\n   / \\     \n  4   5    \n\n返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。\n 思路\n递归，其实最大直径就是左子树的深度+右子树的深度。\n code\nclass Solution &#123;    private int res=0;    public int diameterOfBinaryTree(TreeNode root) &#123;        deep(root);        return res;    &#125;    public int deep(TreeNode node)&#123;        if (node==null)return -1;        int left=deep(node.left)+1;        int right=deep(node.right)+1;        res=Math.max(res,left+right);        return Math.max(left,right);    &#125;&#125;\n 11-20\n 11 1013. 将数组分成和相等的三个部分\n 题目\n给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。\n形式上，如果可以找出索引i+1 &lt; j且满足 (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1])就可以将数组三等分。\n示例 1：\n输入：[0,2,1,-6,6,-7,9,1,2,0,1]输出：true解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1\n示例 2：\n输入：[0,2,1,-6,6,7,9,-1,2,0,1]输出：false\n示例 3：\n输入：[3,3,6,5,-2,2,5,1,-9,4]输出：true解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4\n 思路\n先计算出总和，看能不能被3整除，然后模拟一下即可。\n code\nclass Solution&#123;    public boolean canThreePartsEqualSum(int[] A) &#123;        int sum = 0;        for (int num: A) &#123;            sum += num;        &#125;        if (sum % 3 != 0) &#123;            return false;        &#125;        sum /= 3;        int curSum = 0, cnt = 0;        for (int i = 0; i &lt; A.length; i++) &#123;            curSum += A[i];            if (curSum == sum) &#123;                cnt++;                curSum = 0;            &#125;        &#125;        // 最后判断是否找到了3段（注意如果目标值是0的话可以大于3段）        return cnt == 3 || (cnt &gt; 3 &amp;&amp; sum == 0);    &#125;&#125;\n 12 1071. 字符串的最大公因子\n 题目\n对于字符串 S 和 T，只有在 S = T + … + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。\n返回最长字符串 X，要求满足 X 能除尽str1且 X 能除尽str2。\n示例 1：\n输入：str1 = &quot;ABCABC&quot;, str2 = &quot;ABC&quot;输出：&quot;ABC&quot;\n示例 2：\n输入：str1 = &quot;ABABAB&quot;, str2 = &quot;ABAB&quot;输出：&quot;AB&quot;\n示例 3：\n输入：str1 = &quot;LEET&quot;, str2 = &quot;CODE&quot;输出：&quot;&quot;\n提示：\n\n1 &lt;= str1.length &lt;= 1000\n1 &lt;= str2.length &lt;= 1000\nstr1[i]和str2[i]为大写英文字母\n\n 思路\n如果两个字符串有公因子串，则必有str1+str2=str2+str1，用辗转相除法计算出长度的最大公因数，截取其中一段即为最大公因子串了。\n code\nclass Solution &#123;    public String gcdOfStrings(String str1, String str2) &#123;        if (!(str1+str2).equals(str2+str1))return &quot;&quot;;        return str1.substring(0,gcd(str1.length(),str2.length()));    &#125;    private int gcd(int a, int b)&#123;        return b==0?a:gcd(b,a%b);    &#125;&#125;\n 13 169. 多数元素\n 题目\n给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n示例 1:\n输入: [3,2,3]输出: 3\n示例 2:\n输入: [2,2,1,1,1,2,2]输出: 2\n 思路\n从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，因为最多的数出现的次数大于一半，所以最后总会找到这个数。\n code\nclass Solution &#123;    public int majorityElement(int[] nums) &#123;        int cur=nums[0];        int count=0;        for (int num : nums) &#123;            if (num==cur)count++;            else if (count==0)&#123;                cur=num;                count=1;            &#125;else count--;        &#125;        return cur;    &#125;&#125;\n 14 300. 最长上升子序列\n 题目\n给定一个无序的整数数组，找到其中最长上升子序列的长度。\n示例:\n\n输入: [10,9,2,5,3,7,101,18]\n输出: 4\n解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。\n\n说明:\n可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。\n你算法的时间复杂度应该为 O(n2)O(n^2)O(n2) 。\n 思路\n常规dp就可以O(n2)O(n^2)O(n2)，这里参考官方题解的贪心+二分。\n\n考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。\n基于上面的贪心思路，我们维护一个数组 d[i] ，表示长度为 ii 的最长上升子序列的末尾元素的最小值，用 lenlenlen 记录目前最长上升子序列的长度，起始时 lenlenlen 为 11，d[1]=nums[0]d[1]=nums[0]d[1]=nums[0]。\n同时我们可以注意到 d[i]d[i] 是关于 ii 单调递增的。因为如果 d[j]≥d[i]d[j] \\geq d[i]d[j]≥d[i]且$ j &lt; i$，我们考虑从长度为 ii 的最长上升子序列的末尾删除 i−ji-ji−j 个元素，那么这个序列长度变为 j，且第 j个元素 xx（末尾元素）必然小于 d[i]，也就小于 d[j]。那么我们就找到了一个长度为 j的最长上升子序列，并且末尾元素比 d[j] 小，从而产生了矛盾。因此数组 d[] 的单调性得证。\n我们依次遍历数组 $nums[] $中的每个元素，并更新数组 d[]d[] 和 lenlenlen 的值。如果$ \\textit{nums}[i] &gt; d[\\textit{len}] $则更新 len=len+1len = len + 1len=len+1，否则在 d[1…len]d[1 \\ldots len]d[1…len]中找满足$ d[i−1]&lt;nums[j]&lt;d[i] $的下标 ii，并更新 d[i]=nums[j]d[i]=nums[j]d[i]=nums[j]。\n根据 d 数组的单调性，我们可以使用二分查找寻找下标 i，优化时间复杂度。\n最后整个算法流程为：\n设当前已求出的最长上升子序列的长度为$ len$（初始时为 11），从前往后遍历数组 numsnumsnums，在遍历到 $nums[i] $时：\n如果$nums[i]&gt;d[len] $，则直接加入到 d 数组末尾，并更新 len=len+1len=len+1len=len+1；\n否则，在 d 数组中二分查找，找到第一个比$nums[i] $小的数 d[k] ，并更新 d[k+1]=nums[i]d[k+1]=nums[i]d[k+1]=nums[i]。\n作者：LeetCode-Solution\n链接：https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/\n\n code\nclass Solution &#123;    public int lengthOfLIS(int[] nums) &#123;        int len = 1, n = (int)nums.length;        if (n == 0) return 0;        int[] d=new int[n+1];        d[len] = nums[0];        for (int i = 1; i &lt; n; ++i) &#123;            if (nums[i] &gt; d[len]) d[++len] = nums[i];            else&#123;                int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0                while (l &lt;= r) &#123;                    int mid = (l + r) &gt;&gt; 1;                    if (d[mid] &lt; nums[i]) &#123;                        pos = mid;                        l = mid + 1;                    &#125;                    else r = mid - 1;                &#125;                d[pos + 1] = nums[i];            &#125;        &#125;        return len;    &#125;&#125;\n 15 695. 岛屿的最大面积\n 题目\n给定一个包含了一些 0 和 1 的非空二维数组 grid 。\n一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。\n找到给定的二维数组中最大的岛屿面积。（如果没有岛屿，则返回面积为 0 。)\n示例 1:\n[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]]\n对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。\n示例 2:\n[[0,0,0,0,0,0,0,0]]\n对于上面这个给定的矩阵, 返回 0。\n 思路\n对于每个1进行dfs。下面的代码其实可以不必使用cur标记是否访问，直接对访问过进行置0即可。\n code\nclass Solution &#123;    private int[][]conditions=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;    private boolean[][] cur;    private int res=0;    public int maxAreaOfIsland(int[][] grid) &#123;        if (grid.length==0||grid[0].length==0)return 0;        cur=new boolean[grid.length][grid[0].length];        int cur_res=0;        for (int i = 0; i &lt; grid.length; i++) &#123;            for (int j = 0; j &lt; grid[0].length; j++) &#123;                if (grid[i][j]==1&amp;&amp;!cur[i][j])&#123;                    cur_res=maxAreaOfIsland(grid,i,j);                    res=Math.max(res,cur_res);                &#125;            &#125;        &#125;        return res;    &#125;    public int maxAreaOfIsland(int[][] grid,int i,int j)&#123;        int cur_res=0;        if (i&lt;0||i==grid.length||j&lt;0||j==grid[0].length||cur[i][j]||grid[i][j]!=1)return cur_res;        cur_res++;        cur[i][j]=true;        for (int k = 0; k &lt; 4; k++) &#123;            cur_res+=maxAreaOfIsland(grid,i+conditions[k][0],j+conditions[k][1]);        &#125;        return cur_res;    &#125;&#125;\n 16 面试题 01.06. 字符串压缩\n 题目\n字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。\n示例1:\n输入：&quot;aabcccccaaa&quot;输出：&quot;a2b1c5a3&quot;\n示例2:\n输入：&quot;abbccd&quot;输出：&quot;abbccd&quot;解释：&quot;abbccd&quot;压缩后为&quot;a1b2c2d1&quot;，比原字符串长度更长。\n提示：\n\n字符串长度在[0, 50000]范围内。\n\n 思路\n直接模拟这个过程即可。\n code\nclass Solution &#123;    public String compressString(String S) &#123;        if (S.length()&lt;3)return S;        StringBuilder sb=new StringBuilder();        char c=S.charAt(0);        int count=1;        for (int i = 1; i &lt; S.length(); i++) &#123;            if (S.charAt(i)==c)&#123;                count++;            &#125;else &#123;                sb.append(c).append(count);                if (sb.length()&gt;=S.length())&#123;                    return S;                &#125;                c=S.charAt(i);                count=1;            &#125;        &#125;        sb.append(c).append(count);        if (sb.length()&gt;=S.length())&#123;            return S;        &#125;        return sb.toString();    &#125;&#125;\n 17 1160. 拼写单词\n 题目\n给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。\n假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。\n注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。\n返回词汇表 words 中你掌握的所有单词的 长度之和。\n示例 1：\n输入：words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot;输出：6解释： 可以形成字符串 &quot;cat&quot; 和 &quot;hat&quot;，所以答案是 3 + 3 = 6。\n示例 2：\n输入：words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot;输出：10解释：可以形成字符串 &quot;hello&quot; 和 &quot;world&quot;，所以答案是 5 + 5 = 10。\n提示：\n\n1 &lt;= words.length &lt;= 1000\n1 &lt;= words[i].length, chars.length &lt;= 100\n所有字符串中都仅包含小写英文字母\n\n 思路\n只有26个字母，直接数组哈希。逐个测试即可。\n code\nclass Solution &#123;    public int countCharacters(String[] words, String chars) &#123;        int[] hash = new int[26];        for(char ch : chars.toCharArray())&#123;            hash[ch - &#x27;a&#x27;] += 1;        &#125;        int[] map = new int[26];        int len = 0;        for(String word : words)&#123;            Arrays.fill(map, 0);            boolean flag = true;            for(char ch : word.toCharArray())&#123;                map[ch - &#x27;a&#x27;]++;                if(map[ch - &#x27;a&#x27;] &gt; hash[ch - &#x27;a&#x27;]) flag = false;            &#125;            len += flag ? word.length() : 0;            &#125;        return len;    &#125;&#125;\n 18 836. 矩形重叠\n 题目\n矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。\n如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。\n给出两个矩形，判断它们是否重叠并返回结果。\n示例 1：\n输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]输出：true\n示例 2：\n输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]输出：false\n提示：\n\n两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。\n矩形中的所有坐标都处于 -10^9 和 10^9 之间。\nx 轴默认指向右，y 轴默认指向上。\n你可以仅考虑矩形是正放的情况。\n\n 思路\n矩形如果不重叠，从x轴和y轴上看两个矩形就变成了两条线段，这两条线段肯定是不相交的，也就是说左边的矩形的最右边小于右边矩形的最左边，也就是rec1[2] &lt; rec2[0] || rec2[2] &lt; rec1[0]；y轴同理，下面的矩形的最上边小于上面矩形的最下边，也就是rec1[3] &lt; rec2[1] || rec2[3] &lt; rec1[1]。因为题目要求重叠算相离，所以加上=，最后取反就行啦~\n code\nclass Solution &#123;    public boolean isRectangleOverlap(int[] rec1, int[] rec2) &#123;        return !(rec1[0] &gt;= rec2[2] || rec1[2] &lt;= rec2[0] || rec1[1] &gt;= rec2[3] || rec1[3] &lt;= rec2[1]);    &#125;&#125;\n 19 409. 最长回文串\n 题目\n给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。\n在构造过程中，请注意区分大小写。比如 &quot;Aa&quot; 不能当做一个回文字符串。\n注意:\n假设字符串的长度不会超过 1010。\n示例 1:\n输入:&quot;abccccdd&quot;输出:7解释:我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。\n 思路\n直接统计每个字符的个数。只要是复数出现的即可，最后还可以加上一个正中间的。\n code\nclass Solution &#123;    public int longestPalindrome(String s) &#123;        int[] cnts = new int[58];         for (int i = 0; i &lt; s.length(); i++) &#123;             cnts[s.charAt(i) - &#x27;A&#x27;]++;         &#125;         int palindrome = 0;         for (int cnt : cnts) &#123;             palindrome += (cnt / 2) * 2;         &#125;         if (palindrome &lt; s.length()) &#123;             palindrome++;         &#125;         return palindrome;    &#125;&#125;\n 20 面试题40. 最小的k个数\n 题目\n输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。\n示例 1：\n输入：arr = [3,2,1], k = 2输出：[1,2] 或者 [2,1]\n示例 2：\n输入：arr = [0,1,2,1], k = 1输出：[0]\n限制：\n\n0 &lt;= k &lt;= arr.length &lt;= 10000\n0 &lt;= arr[i] &lt;= 10000\n\n 思路\n二分法，每次取mid，将数组分为两个部分，如果小的那部分&gt;k，则继续再这部分进行二分，如果&lt;k，则这些数都是结果，再在大的部分继续取剩下的数，如果刚好等于要取的数，则结束。\n code\nclass Solution &#123;    public int[] getLeastNumbers(int[] arr, int k) &#123;        int[] res=new int[k];        int len=arr.length;        int leftL,rightL;        int[] left=new int[len];        int[] right=new int[len];        int index=0;        int mid;        int[] midA=new int[len];        int midL;        while (index&lt;k)&#123;            leftL=0;rightL=0;midL=0;            mid=arr[len/2];            for (int i = 0; i &lt; len; i++) &#123;                if (arr[i]&lt;mid)&#123;                    left[leftL++]=arr[i];                &#125;else if (arr[i]==mid)midA[midL++]=arr[i];                else right[rightL++]=arr[i];            &#125;            if (leftL&gt;(k-index))&#123;                arr=left;                len=leftL;            &#125;else &#123;                for (int i = 0; i &lt; leftL; i++) &#123;                    res[index++]=left[i];                &#125;                int tmp=0;                while (index&lt;k&amp;&amp;tmp&lt;midL)&#123;                    res[index++]=midA[tmp++];                &#125;                arr=right;                len=rightL;            &#125;        &#125;        return res;    &#125;&#125;\n 21-31\n 21 365. 水壶问题\n 题目\n有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？\n如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。\n你允许：\n\n装满任意一个水壶\n清空任意一个水壶\n从一个水壶向另外一个水壶倒水，直到装满或者倒空\n\n示例 1: (From the famous “Die Hard” example)\n输入: x = 3, y = 5, z = 4输出: True\n示例 2:\n输入: x = 2, y = 6, z = 5输出: False\n 思路\n\n预备知识：贝祖定理\n我们认为，每次操作只会让桶里的水总量增加 x，增加 y，减少 x，或者减少 y。\n你可能认为这有问题：如果往一个不满的桶里放水，或者把它排空呢？那变化量不就不是 x 或者 y 了吗？接下来我们来解释这一点：\n首先要清楚，在题目所给的操作下，两个桶不可能同时有水且不满。因为观察所有题目中的操作，操作的结果都至少有一个桶是空的或者满的；\n其次，对一个不满的桶加水是没有意义的。因为如果另一个桶是空的，那么这个操作的结果等价于直接从初始状态给这个桶加满水；而如果另一个桶是满的，那么这个操作的结果等价于从初始状态分别给两个桶加满；\n再次，把一个不满的桶里面的水倒掉是没有意义的。因为如果另一个桶是空的，那么这个操作的结果等价于回到初始状态；而如果另一个桶是满的，那么这个操作的结果等价于从初始状态直接给另一个桶倒满。\n因此，我们可以认为每次操作只会给水的总量带来 x 或者 y 的变化量。因此我们的目标可以改写成：找到一对整数 a,b，使得\nax+by=zax+by=z\nax+by=z\n而只要满足z≤x+y，且这样的 a,b 存在，那么我们的目标就是可以达成的。这是因为：\n\n\n若a≥0,b≥0，那么显然可以达成目标。\n\n\n若a&lt;0，那么可以进行以下操作：\n\n\n往 y 壶倒水；\n\n\n把 y 壶的水倒入 x 壶；\n\n\n如果 y 壶不为空，那么 x 壶肯定是满的，把 x 壶倒空，然后再把 y 壶的水倒入 x 壶。\n\n\n重复以上操作直至某一步时 x 壶进行了 a 次倒空操作，y 壶进行了 b 次倒水操作。\n\n\n若 b&lt;0，方法同上，x 与 y 互换。\n\n\n而贝祖定理告诉我们，ax+by=z 有解当且仅当 z 是 x,y 的最大公约数的倍数。因此我们只需要找到x,y 的最大公约数并判断 z 是否是它的倍数即可。\n\n code\nclass Solution &#123;    public boolean canMeasureWater(int x, int y, int z) &#123;       if (x+y&lt;z)return false;       if (x+y==z||x==z||y==z||x==1||y==1)return true;       if (x==y||x==0||y==0)return false;        if(z==0)return true;        int gcd=getGCD(x,y);        if (gcd==1)return true;        return gcd&lt;z&amp;&amp;z%gcd==0;    &#125;    private int getGCD(int a, int b) &#123;        if (a &lt; 0 || b &lt; 0) &#123;            return -1; // 数学上不考虑负数的约数        &#125;        if (b == 0) &#123;            return a;        &#125;        while (a % b != 0) &#123;            int temp = a % b;            a = b;            b = temp;        &#125;        return b;    &#125;&#125;\n 22 945. 使数组唯一的最小增量\n 题目\n给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。\n返回使 A 中的每个值都是唯一的最少操作次数。\n示例 1:\n输入：[1,2,2]输出：1解释：经过一次 move 操作，数组将变为 [1, 2, 3]。\n示例 2:\n输入：[3,2,1,2,1,7]输出：6解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。\n提示：\n\n0 &lt;= A.length &lt;= 40000\n0 &lt;= A[i] &lt; 40000\n\n 思路\n首先模拟也可以做，但是很慢，所以可以利用空间换时间的方法，记录下所有的数出现的次数，遍历这些数，对于每个数出现次数&gt;1的数进行次数-1的move操作，所以该数+1要的次数要加上该数的次数-1，结果加上move的次数即可。\n code\nclass Solution &#123;    public int minIncrementForUnique(int[] A) &#123;        // Arrays.sort(A);        // int res=0;        // for (int i = 1; i &lt; A.length; i++) &#123;        //     while (A[i]&lt;=A[i-1])&#123;        //         A[i]++;        //         res++;        //     &#125;        // &#125;        // return res;        //空间换时间        int[] arr=new int[50000];        int res=0;        for(int i:A)&#123;            arr[i]++;        &#125;        for (int i = 0; i &lt; 50000; i++) &#123;            if (arr[i]&gt;1)&#123;                arr[i+1]+=arr[i]-1;                res+=arr[i]-1;            &#125;        &#125;        return res;    &#125;&#125;\n 23 876. 链表的中间结点\n 题目\n给定一个带有头结点 head 的非空单链表，返回链表的中间结点。\n如果有两个中间结点，则返回第二个中间结点。\n示例 1：\n输入：[1,2,3,4,5]输出：此列表中的结点 3 (序列化形式：[3,4,5])返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。注意，我们返回了一个 ListNode 类型的对象 ans，这样：ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.\n示例 2：\n输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。\n提示：\n\n给定链表的结点数介于 1 和 100 之间。\n\n 思路\n经典的快慢指针用法。\n code\nclass Solution &#123;    public ListNode middleNode(ListNode head) &#123;        // 快慢指针        ListNode low = head, fast = head;        while (fast != null &amp;&amp; fast.next != null) &#123;            fast = fast.next.next;            low = low.next;        &#125;        return low;    &#125;&#125;\n 24 面试题 17.16. 按摩师\n 题目\n一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。\n注意：本题相对原题稍作改动\n示例 1：\n输入： [1,2,3,1]输出： 4解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。\n示例 2：\n输入： [2,7,9,3,1]输出： 12解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。\n示例 3：\n输入： [2,1,4,5,3,1,1,3]输出： 12解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。\n 思路\n动态规划：dp[i]=max⁡(dp[i−1],dp[i−2]+nums[i])dp[i]=\\max(dp[i-1],dp[i-2]+nums[i])dp[i]=max(dp[i−1],dp[i−2]+nums[i])\n code\nclass Solution &#123;    public int massage(int[] nums) &#123;        if (nums.length==0)return 0;        if (nums.length==1)return nums[0];        int[] dp=new int[nums.length];        dp[0]=nums[0];        dp[1]= Math.max(nums[1], nums[0]);        for (int i = 2; i &lt; nums.length; i++) &#123;            dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i]);        &#125;        return dp[nums.length-1];    &#125;&#125;\n 25 892. 三维形体的表面积\n 题目\n在 N * N 的网格上，我们放置一些 1 * 1 * 1 的立方体。\n每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。\n请你返回最终形体的表面积。\n示例 1：\n输入：[[2]]输出：10\n示例 2：\n输入：[[1,2],[3,4]]输出：34\n示例 3：\n输入：[[1,0],[0,2]]输出：16\n示例 4：\n输入：[[1,1,1],[1,0,1],[1,1,1]]输出：32\n示例 5：\n输入：[[2,2,2],[2,1,2],[2,2,2]]输出：46\n提示：\n\n1 &lt;= N &lt;= 50\n0 &lt;= grid[i][j] &lt;= 50\n\n 思路\n对于每个格子里的正方体，首先是上下两个面，然后是每个有四个侧面，最后减去重复计算的侧面即可。\n code\nclass Solution &#123;    public int surfaceArea(int[][] grid) &#123;        if (grid.length==0||grid[0].length==0)return 0;        int res=0;        for (int i = 0; i &lt; grid.length; i++) &#123;            for (int j = 0; j &lt; grid[0].length; j++) &#123;                if (grid[i][j]!=0)&#123;                    res+=2;                    res+=grid[i][j]&lt;&lt;2;                    if (i&gt;0)res-=Math.min(grid[i][j],grid[i-1][j])&lt;&lt;1;                    if (j&gt;0)res-=Math.min(grid[i][j],grid[i][j-1])&lt;&lt;1;                    // if (i&lt;grid.length-1)res-=Math.min(grid[i][j],grid[i+1][j]);                    // if (j&lt;grid[0].length-1)res-=Math.min(grid[i][j],grid[i][j+1]);                &#125;            &#125;        &#125;        return res;    &#125;&#125;\n 26 999. 可以被一步捕获的棋子数\n 题目\n在一个 8 x 8 的棋盘上，有一个白色的车（Rook），用字符 'R' 表示。棋盘上还可能存在空方块，白色的象（Bishop）以及黑色的卒（pawn），分别用字符 '.'，'B' 和 'p' 表示。不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。\n车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动，直到满足下列四个条件之一：\n\n棋手选择主动停下来。\n棋子因到达棋盘的边缘而停下。\n棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。\n车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。\n\n你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内（即，可以被一步捕获的棋子数）。\n示例 1：\n\n输入：[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]输出：3解释：在本例中，车能够捕获所有的卒。\n提示：\n\nboard.length == board[i].length == 8\nboard[i][j]可以是'R'，'.'，'B'或 'p'\n只有一个格子上存在board[i][j] == 'R'\n\n 思路\n很没意思的一道题。。。。\n code\nclass Solution &#123;    public int numRookCaptures(char[][] board) &#123;        int res=0;        int row=0,col=0;        for (int i = 0; i &lt; board.length; i++) &#123;            for (int j = 0; j &lt; board[i].length; j++) &#123;                if (board[i][j]==&#x27;R&#x27;)&#123;                    row=i;col=j;break;                &#125;            &#125;        &#125;        int tmp=row-1;        while (tmp&gt;=0)&#123;            char c=board[tmp][col];            if (c==&#x27;B&#x27;)break;            if (c==&#x27;p&#x27;)&#123;res++;break;&#125;            tmp--;        &#125;        tmp=row+1;        while (tmp&lt;board.length)&#123;            char c=board[tmp][col];            if (c==&#x27;B&#x27;)break;            if (c==&#x27;p&#x27;)&#123;res++;break;&#125;            tmp++;        &#125;        tmp=col-1;        while (tmp&gt;=0)&#123;            char c=board[row][tmp];            if (c==&#x27;B&#x27;)break;            if (c==&#x27;p&#x27;)&#123;res++;break;&#125;            tmp--;        &#125;        tmp=col+1;        while (tmp&lt;board[0].length)&#123;            char c=board[row][tmp];            if (c==&#x27;B&#x27;)break;            if (c==&#x27;p&#x27;)&#123;res++;break;&#125;            tmp++;        &#125;        return res;    &#125;&#125;\n 27 914. 卡牌分组\n 题目\n给定一副牌，每张牌上都写着一个整数。\n此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：\n\n每组都有 X 张牌。\n组内所有的牌上都写着相同的整数。\n\n仅当你可选的 X &gt;= 2 时返回 true。\n示例 1：\n输入：[1,2,3,4,4,3,2,1]输出：true解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]\n示例 2：\n输入：[1,1,1,2,2,2,3,3]输出：false解释：没有满足要求的分组。\n示例 3：\n输入：[1]输出：false解释：没有满足要求的分组。\n示例 4：\n输入：[1,1]输出：true解释：可行的分组是 [1,1]\n示例 5：\n输入：[1,1,2,2,2,2]输出：true解释：可行的分组是 [1,1]，[2,2]，[2,2]\n提示：\n\n1 &lt;= deck.length &lt;= 10000\n0 &lt;= deck[i] &lt; 10000\n\n 思路\n先给这些牌排个序。\n然后记录所有牌的张数。以及最少的张数。\n然后从2…最少的张数进行测试可否分组。\n下面的代码写成hash会更好一点，懒得写了。。\n code\nclass Solution &#123;    public boolean hasGroupsSizeX(int[] deck) &#123;        Arrays.sort(deck);        List&lt;Integer&gt; list=new ArrayList&lt;&gt;();        int min=Integer.MAX_VALUE;        int tmp=1;        for (int i = 1; i &lt; deck.length; i++) &#123;            if (deck[i]==deck[i-1])tmp++;            else &#123;                if (tmp==1)return false;                min=Math.min(min,tmp);                list.add(tmp);                tmp=1;            &#125;        &#125;        if (tmp==1)return false;        min=Math.min(min,tmp);        list.add(tmp);        tmp=min;        boolean flag=true;        for (int i = 2; i &lt;= min; i++) &#123;            flag=true;            if (min%i==0)&#123;                for (Integer ii:list)&#123;                    if (ii % i != 0) &#123;                        flag = false;                        break;                    &#125;                &#125;                if (flag)return true;            &#125;        &#125;        return false;    &#125;&#125;\n 28 820. 单词的压缩编码\n 题目\n给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。\n例如，如果这个列表是 [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]，我们就可以将其表示为 S = &quot;time#bell#&quot; 和 indexes = [0, 2, 5]。\n对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。\n那么成功对给定单词列表进行编码的最小字符串长度是多少呢？\n示例：\n输入: words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]输出: 10说明: S = &quot;time#bell#&quot; ， indexes = [0, 2, 5] 。\n提示：\n\n1 &lt;= words.length &lt;= 2000\n1 &lt;= words[i].length &lt;= 7\n每个单词都是小写字母 。\n\n 思路\n很烂的思路，先对单词进行按长度排序。然后遍历判断是否以其他单词结尾的，如果有单词被别的单词包含就不计算，最后的结果就是没有被包含的单词的长度+1的和。\n最好的做法是用字典树（前缀树），奈何不会~待学。。\n这道题将字符串倒过来就是判断前缀是否包含单词了。\n code\nclass Solution &#123;    public int minimumLengthEncoding(String[] words) &#123;        Arrays.sort(words,(a,b)-&gt;(Integer.compare(b.length(), a.length())));        boolean[] flags=new boolean[words.length];        for (int i = 0; i &lt; words.length; i++) &#123;            String tmp=words[i];            for (int j = i+1; j &lt; words.length; j++) &#123;                if (!flags[j]&amp;&amp;tmp.endsWith(words[j]))&#123;                    flags[j]=true;                &#125;            &#125;        &#125;        int res=0;        for (int i = 0; i &lt; words.length; i++) &#123;            if (!flags[i])res+=words[i].length()+1;        &#125;        return res;    &#125;&#125;\n字典树做法\nclass Solution &#123;    public int minimumLengthEncoding(String[] words) &#123;        int len = 0;        Trie trie = new Trie();        // 先对单词列表根据单词长度由长到短排序        Arrays.sort(words, (s1, s2) -&gt; s2.length() - s1.length());        // 单词插入trie，返回该单词增加的编码长度        for (String word: words) &#123;            len += trie.insert(word);        &#125;        return len;    &#125;&#125;// 定义tireclass Trie &#123;        TrieNode root;        public Trie() &#123;        root = new TrieNode();    &#125;    public int insert(String word) &#123;        TrieNode cur = root;        boolean isNew = false;        // 倒着插入单词        for (int i = word.length() - 1; i &gt;= 0; i--) &#123;            int c = word.charAt(i) - &#x27;a&#x27;;            if (cur.children[c] == null) &#123;                isNew = true; // 是新单词                cur.children[c] = new TrieNode();            &#125;            cur = cur.children[c];        &#125;        // 如果是新单词的话编码长度增加新单词的长度+1，否则不变。        return isNew? word.length() + 1: 0;    &#125;&#125;class TrieNode &#123;    char val;    TrieNode[] children = new TrieNode[26];    public TrieNode() &#123;&#125;&#125;\n 29 1162. 地图分析\n 题目\n你现在手里有一份大小为 N x N 的「地图」（网格） grid，上面的每个「区域」（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，请你找出一个海洋区域，这个海洋区域到离它最近的陆地区域的距离是最大的。\n我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。\n如果我们的地图上只有陆地或者海洋，请返回 -1。\n示例 1：\n\n输入：[[1,0,1],[0,0,0],[1,0,1]]输出：2解释： 海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。\n示例 2：\n\n输入：[[1,0,0],[0,0,0],[0,0,0]]输出：4解释： 海洋区域 (2, 2) 和所有陆地区域之间的距离都达到最大，最大距离为 4。\n提示：\n\n1 &lt;= grid.length == grid[0].length &lt;= 100\ngrid[i][j] 不是 0 就是 1\n\n 思路\n先找出所有的陆地，再从陆地开始进行分层的BFS，遍历的最大深度即为解。\n code\nclass Solution &#123;    private int[][]conditions=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;    public int maxDistance(int[][] grid) &#123;        // BFS        int N=grid.length;        Queue&lt;int[]&gt; queue=new LinkedList&lt;&gt;();        for (int i = 0; i &lt; N; i++) &#123;            for (int j = 0; j &lt; N; j++) &#123;                if (grid[i][j]==1)&#123;                    queue.add(new int[]&#123;i,j&#125;);                &#125;            &#125;        &#125;        if (queue.size()==N*N||queue.size()==0)return -1;        int res=-1;        while (!queue.isEmpty())&#123;            res++;            int tmp=queue.size();            for (int k = 0; k &lt; tmp; k++) &#123;                int[] poi=queue.poll();                int i=poi[0],j=poi[1];                for (int l = 0; l &lt; 4; l++) &#123;                    int newi=i+conditions[l][0];                    int newj=j+conditions[l][1];                    if (newi&lt;0||newj&lt;0||newi==N||newj==N)continue;                    if (grid[newi][newj]==0)&#123;                        grid[newi][newj]=-1;                        queue.add(new int[]&#123;newi,newj&#125;);                    &#125;                &#125;            &#125;        &#125;        return res;    &#125;&#125;\n 30 面试题62. 圆圈中最后剩下的数字\n 题目\n0,1,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。\n例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。\n示例 1：\n输入: n = 5, m = 3输出: 3\n示例 2：\n输入: n = 10, m = 17输出: 2\n限制：\n\n1 &lt;= n &lt;= 10^5\n1 &lt;= m &lt;= 10^6\n\n 思路\n首先是模拟这个过程，但是会超时，官方给出数学法：\n\n【思路】\nn个数字的圆圈，不断删除第m个数字，我们把最后剩下的数字记为f(n,m)\nn个数字中第一个被删除的数字是(m-1)%n (取余的原因是m可能比n大)， 我们记作k，k=(m-1)%n\n那么剩下的n-1个数字就变成了：0,1,……k-1,k+1,……,n-1，我们把下一轮第一个数字排在最前面，并且将这个长度为n-1的数组映射到0~n-2。\n\n\n\n原始数组\n映射数字\n\n\n\n\nk+1\n0\n\n\nk+2\n1\n\n\n…\n…\n\n\nn-1\nn-k-2\n\n\n0\nn-k-1\n\n\n…\n…\n\n\nk-1\nn-2\n\n\n\n把映射数字记为x，原始数字记为y，那么映射数字变回原始数字的公式为\ny=(x+k+1)mod  ny=(x+k+1)\\mod n\ny=(x+k+1)modn\n在映射数字中，n-1个数字，不断删除第m个数字，由定义可以知道，最后剩下的数字为f(n-1,m)。我们把它变回原始数字，由上一个公式可以得到最后剩下的原始数字是（f(n-1,m)+k+1)%n，而这个数字也就是一开始我们标记的f(n,m)，所以可以推得递归公式为\nf(n,m)=(f(n−1,m)+k+1)mod  nf(n,m) =(f(n-1,m)+k+1)\\mod n\nf(n,m)=(f(n−1,m)+k+1)modn\n将k=(m-1)%n代入，化简得到：\nf(n,m)=(f(n−1,m)+m)mod  n，且f(1,m)=0f(n,m) =(f(n-1,m)+m)\\mod n， 且f(1,m) = 0\nf(n,m)=(f(n−1,m)+m)modn，且f(1,m)=0\n代码中可以采用迭代或者递归的方法实现该递归公式。时间复杂度为O(n)，空间复杂度为O(1)\n注意公式中的mod就等同于%，为取模运算。值得注意的是，在数学中，下式成立：(a%n+b)%n=(a+b)%n\n\n code\nclass Solution &#123;    public int lastRemaining(int n, int m) &#123;        // 模拟法        // boolean[] flag=new boolean[n];        // int index=-1;        // int tmp;        // for (int i = 0; i &lt; n-1; i++) &#123;        //     tmp=m;        //     while (tmp!=0)&#123;        //         if (++index==n)index=0;        //         if (!flag[index])&#123;        //             --tmp;        //         &#125;        //     &#125;        //     flag[index]=true;        // &#125;        // for (int i = 0; i &lt; n; i++) &#123;        //     if (!flag[i])return i;        // &#125;        // return 0;        // 数学法tql        int res = 0;        for (int i = 2; i &lt;= n; i++) &#123;            res = (res + m) % i;        &#125;        return res;    &#125;&#125;\n 31 912. 排序数组\n 题目\n给你一个整数数组 nums，请你将该数组升序排列。\n示例 1：\n输入：nums = [5,2,3,1]输出：[1,2,3,5]\n示例 2：\n输入：nums = [5,1,1,2,0,0]输出：[0,0,1,1,2,5]\n提示：\n\n1 &lt;= nums.length &lt;= 50000\n-50000 &lt;= nums[i] &lt;= 50000\n\n 思路\n各种排序~\n code\nclass Solution &#123;    public int[] sortArray(int[] nums) &#123;        Arrays.sort(nums);        return nums;    &#125;&#125;","categories":["algorithm"],"tags":["leetcode"]},{"title":"Leetcode 2020-04月份每日一题","url":"/posts/20-04-leetcode.html","content":"\n 1-10\n 01 1111. 有效括号的嵌套深度\n 题目\n有效括号字符串 定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「有效括号字符串」部分。\n嵌套深度 depth 定义：即有效括号字符串嵌套的层数，depth(A) 表示有效括号字符串 A 的嵌套深度。详情参见题末「嵌套深度」部分。\n有效括号字符串类型与对应的嵌套深度计算方法如下图所示：\n\n给你一个「有效括号字符串」 seq，请你将其分成两个不相交的有效括号字符串，A 和 B，并使这两个字符串的深度最小。\n\n\n不相交：每个 seq[i] 只能分给 A 和 B 二者中的一个，不能既属于 A 也属于 B 。\n\n\nA 或 B 中的元素在原字符串中可以不连续。\n\n\nA.length + B.length = seq.length\n\n\n深度最小：max(depth(A), depth(B)) 的可能取值最小。\n\n\n划分方案用一个长度为 seq.length 的答案数组 answer 表示，编码规则如下：\n\nanswer[i] = 0，seq[i] 分给 A 。\nanswer[i] = 1，seq[i] 分给 B 。\n\n如果存在多个满足要求的答案，只需返回其中任意 一个 即可。\n 思路\n首先的思路是使用栈，先计算出最大深度是多少，然后可知分成两部分的最大深度最大为(depth+1)/2；所以在此使用栈进行记录，每当碰到括号深度大于最大深度时，就分配给另一半。\n进阶：题面中的depth其实就是栈的最大深度。“你需要从中选出任意一组有效括号字符串 A 和 B，使 max(depth(A), depth(B)) 的可能取值最小”。这句话其实相当于让A字符串和B字符串的depth尽可能的接近。为什么呢？因为seq对应的栈上，每个左括号都对应一个深度，而这个左括号，要么是A的，要么是B的。所以，栈上的左括号只要按奇偶分配给A和B就可以啦！\n code\nclass Solution &#123;    public int[] maxDepthAfterSplit(String seq) &#123;//()(())(((())))((()))()        int[] res=new int[seq.length()];        int depth=depthBrackets(seq);        int maxD=(depth+1)/2;        Stack&lt;Character&gt; stack=new Stack&lt;&gt;();        int i=0;        stack.push(seq.charAt(i));res[i]=0;i++;        while (i&lt;seq.length())&#123;            char c=seq.charAt(i);            if (c==&#x27;(&#x27;)stack.push(c);            if (stack.size()&gt;maxD)&#123;                res[i]=1;            &#125;else &#123;                res[i]=0;            &#125;            if (c==&#x27;)&#x27;)stack.pop();            i++;        &#125;        return res;    &#125;    private int depthBrackets(String seq)&#123;        if (seq.length()==0)return 0;        Stack&lt;Character&gt; stack=new Stack&lt;&gt;();        int res=0;        int i=0;        stack.push(seq.charAt(i));        i++;        while (i&lt;seq.length())&#123;            res=Math.max(res,stack.size());            char c=seq.charAt(i);i++;            if (c==&#x27;(&#x27;)stack.push(c);            else stack.pop();        &#125;        return res;    &#125;&#125;//进阶class Solution &#123;    public int[] maxDepthAfterSplit(String seq) &#123;        int[] ans = new int [seq.length()];        int idx = 0;        for(char c: seq.toCharArray()) &#123;            ans[idx++] = c == &#x27;(&#x27; ? ((idx + 1) &amp; 1) : idx &amp; 1;        &#125;        return ans;    &#125;&#125;\n 02 289. 生命游戏\n 题目\n根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。\n给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：\n\n\n如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；\n\n\n如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；\n\n\n如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；\n\n\n如果死细胞周围正好有三个活细胞，则该位置死细胞复活；\n\n\n根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。\n示例：\n输入： [  [0,1,0],  [0,0,1],  [1,1,1],  [0,0,0]]输出：[  [0,0,0],  [1,0,1],  [0,1,1],  [0,1,0]]\n进阶：\n\n你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。\n本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？\n\n 思路\n本题的主要难度是需要原地解决本题，不能开辟新的数组，如果可以就很简单了。所以主要思路就是利用int可以存储多位的思想，先把下一状态存储在高位上，计算完所有之后，再吧高位上的值更新到地位。\n code\nclass Solution &#123;    private int[][] directions=new int[][]&#123;&#123;-1,-1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;1,0&#125;,&#123;1,1&#125;,&#123;-1,1&#125;,&#123;1,-1&#125;&#125;;    public void gameOfLife(int[][] board) &#123;        //int 存储多位        if (board.length==0||board[0].length==0)return;        int live;        for (int i = 0; i &lt; board.length; i++) &#123;            for (int j = 0; j &lt; board[0].length; j++) &#123;                live=0;                for (int k = 0; k &lt; 8; k++) &#123;                    int newi=i+directions[k][0];                    int newj=j+directions[k][1];                    if (newi&gt;=0&amp;&amp;newi&lt;board.length&amp;&amp;newj&gt;=0&amp;&amp;newj&lt;board[0].length)&#123;                        if ((board[newi][newj]&amp;1)==1)live++;                    &#125;                &#125;                if ((board[i][j]&amp;1)==1)&#123;                    if (live==2||live==3)board[i][j]=3;                &#125;else &#123;                    if (live==3)board[i][j]=2;                &#125;            &#125;        &#125;        for (int i = 0; i &lt; board.length; i++) &#123;            for (int j = 0; j &lt; board[0].length; j++) &#123;                board[i][j]&gt;&gt;=1;            &#125;        &#125;    &#125;&#125;\n 03 8. 字符串转换整数 (atoi)\n 题目\n请你来实现一个 atoi函数，使其能将字符串转换成整数。\n首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：\n\n如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。\n假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。\n该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。\n\n注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。\n在任何情况下，若函数不能进行有效的转换时，请返回 0 。\n提示：\n\n本题中的空白字符只包括空格字符 ’ ’ 。\n假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。\n\n示例 1:\n输入: &quot;42&quot;输出: 42\n示例 2:\n输入: &quot;   -42&quot;输出: -42解释: 第一个非空白字符为 &#x27;-&#x27;, 它是一个负号。     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。\n 思路\n搞人心态的题，直接copy\n code\nclass Solution &#123;    public int myAtoi(String str) &#123;        int len = str.length();        // 去除前导空格        int index = 0;        while (index &lt; len) &#123;            if (str.charAt(index) != &#x27; &#x27;) &#123;                break;            &#125;            index++;        &#125;        if (index == len) &#123;            return 0;        &#125;        // 第 1 个字符如果是符号，判断合法性，并记录正负        int sign = 1;        char firstChar = str.charAt(index);        if (firstChar == &#x27;+&#x27;) &#123;            index++;            sign = 1;        &#125; else if (firstChar == &#x27;-&#x27;) &#123;            index++;            sign = -1;        &#125;        // 不能使用 long 类型，这是题目说的        int res = 0;        while (index &lt; len) &#123;            char currChar = str.charAt(index);            // 判断合法性            if (currChar &gt; &#x27;9&#x27; || currChar &lt; &#x27;0&#x27;) &#123;                break;            &#125;            // 题目中说：环境只能存储 32 位大小的有符号整数，因此，需要提前判断乘以 10 以后是否越界            if (res &gt; Integer.MAX_VALUE / 10 || (res == Integer.MAX_VALUE / 10 &amp;&amp; (currChar - &#x27;0&#x27;) &gt; Integer.MAX_VALUE % 10)) &#123;                return Integer.MAX_VALUE;            &#125;            if (res &lt; Integer.MIN_VALUE / 10 || (res == Integer.MIN_VALUE / 10 &amp;&amp; (currChar - &#x27;0&#x27;) &gt; -(Integer.MIN_VALUE % 10))) &#123;                return Integer.MIN_VALUE;            &#125;s            // 每一步都把符号位乘进去            res = res * 10 + sign * (currChar - &#x27;0&#x27;);            index++;        &#125;        return res;    &#125;&#125;\n 04 42. 接雨水\n 题目\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。\n示例:\n输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6\n 思路\n双指针进行遍历，遍历时分别记录两边的最高的柱子，每遍历到一个柱子，判断它与两端的高度，若比两端的最高的柱子都低，则可以接到雨水，若不是更新最高的柱子。\n code\nclass Solution &#123;    public int trap(int[] height) &#123;        if (height==null||height.length&lt;2)return 0;        int len=height.length;        int left=0,right=len-1;        int leftmax=0,rightmax=0;        int res=0;        while (left&lt;right)&#123;            if (height[left]&lt;height[right])&#123;                if (height[left]&gt;leftmax)leftmax=height[left];                else res+=leftmax-height[left];                left++;            &#125;else &#123;                if (height[right]&gt;rightmax)rightmax=height[right];                else res+=rightmax-height[right];                right--;            &#125;        &#125;        return res;    &#125;&#125;\n 05 460. LFU缓存\n 题目\n请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。它应该支持以下操作：get 和 put。\n\nget(key) - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。\nput(key, value)- 如果键已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除最久未使用的键。\n\n「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。\n进阶：\n你是否可以在 O(1) 时间复杂度内执行两项操作？\n示例：\nLFUCache cache = new LFUCache( 2 /* capacity (缓存容量) */ );cache.put(1, 1);cache.put(2, 2);cache.get(1);       // 返回 1cache.put(3, 3);    // 去除 key 2cache.get(2);       // 返回 -1 (未找到key 2)cache.get(3);       // 返回 3cache.put(4, 4);    // 去除 key 1cache.get(1);       // 返回 -1 (未找到 key 1)cache.get(3);       // 返回 3cache.get(4);       // 返回 4\n 思路\n四个数组分别存储键、值，计数以及最近访问的列表。官方O(1)用的是双哈希表。。。\n code\nclass LFUCache &#123;    private int[] keys;    private int[] values;    private int[] counts;    private int[] recents;    private int now;    int flag=0;    public LFUCache(int capacity) &#123;        keys=new int[capacity];        values=new int[capacity];        counts=new int[capacity];        recents=new int[capacity];        now=0;    &#125;    public int get(int key) &#123;        for (int i = 0; i &lt; flag; i++) &#123;            if (key==keys[i])&#123;                counts[i]++;                recents[i]=(++now);                return values[i];            &#125;        &#125;return -1;    &#125;    public void put(int key, int value) &#123;        if (keys.length==0)return;        for (int i = 0; i &lt; flag; i++) &#123;            if (key==keys[i])&#123;                counts[i]++;                values[i]=value;                recents[i]=now++;                return;            &#125;        &#125;        if (flag&lt;values.length)&#123;            keys[flag]=key;            values[flag]=value;            counts[flag]=1;            recents[flag]=now++;            flag++;        &#125;else &#123;            List&lt;Integer&gt; list=new ArrayList&lt;&gt;();            int min=counts[0];            list.add(0);            for (int i = 1; i &lt; counts.length; i++) &#123;                if (counts[i]==min)list.add(i);                else if (counts[i]&lt;min)&#123;                    min=counts[i];                    list.clear();                    list.add(i);                &#125;            &#125;            int index=list.get(0);            for (int i:list)&#123;                if (recents[i]&lt;recents[index])&#123;                    index=i;                &#125;            &#125;            keys[index]=key;            values[index]=value;            counts[index]=1;            recents[index]=now++;        &#125;    &#125;&#125;\n 06 72. 编辑距离\n 题目\n给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。\n你可以对一个单词进行如下三种操作：\n\n插入一个字符\n删除一个字符\n替换一个字符\n\n示例 1：\n输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)rorse -&gt; rose (删除 &#x27;r&#x27;)rose -&gt; ros (删除 &#x27;e&#x27;)\n示例 2：\n输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 &#x27;t&#x27;)inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)exection -&gt; execution (插入 &#x27;u&#x27;)\n 思路\ndp,dp[i][j]记录word1前i和word2前j个字符的最短距离，就可以得出转移方程：dp[i+1][j+1]=word1.charAt(i)==word2.charAt(j)?dp[i][j]:Math.min(dp[i][j],Math.min(dp[i][j+1],dp[i+1][j]))+1;dp[i+1][j+1]=word1.charAt(i)==word2.charAt(j)?dp[i][j]:Math.min(dp[i][j],Math.min(dp[i][j+1],dp[i+1][j]))+1;dp[i+1][j+1]=word1.charAt(i)==word2.charAt(j)?dp[i][j]:Math.min(dp[i][j],Math.min(dp[i][j+1],dp[i+1][j]))+1;\n code\nclass Solution &#123;    public int minDistance(String word1, String word2) &#123;        //dp问题        int[][] dp=new int[word1.length()+1][word2.length()+1];        for (int i = 1; i &lt; word1.length()+1; i++) &#123;            dp[i][0]=i;        &#125;        for (int i = 1; i &lt; word2.length()+1; i++) &#123;            dp[0][i]=i;        &#125;        for (int i = 0; i &lt; word1.length(); i++) &#123;            for (int j = 0; j &lt; word2.length(); j++) &#123;                dp[i+1][j+1]=word1.charAt(i)==word2.charAt(j)?dp[i][j]:Math.min(dp[i][j],Math.min(dp[i][j+1],dp[i+1][j]))+1;            &#125;        &#125;        return dp[word1.length()][word2.length()];    &#125;&#125;\n 07 面试题 01.07. 旋转矩阵\n 题目\n给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。\n不占用额外内存空间能否做到？\n示例 1:\n给定 matrix = [  [1,2,3],  [4,5,6],  [7,8,9]],原地旋转输入矩阵，使其变为:[  [7,4,1],  [8,5,2],  [9,6,3]]\n示例 2:\n给定 matrix =[  [ 5, 1, 9,11],  [ 2, 4, 8,10],  [13, 3, 6, 7],  [15,14,12,16]], 原地旋转输入矩阵，使其变为:[  [15,13, 2, 5],  [14, 3, 4, 1],  [12, 6, 8, 9],  [16, 7,10,11]]\n 思路\n就硬旋转，找出每个值对应的位置，四个交换。\n code\nclass Solution &#123;    public void rotate(int[][] matrix) &#123;        int len=matrix.length;        int temp;        for (int i = 0; i &lt; len/2; i++) &#123;            for (int j = i; j &lt; len-i-1; j++) &#123;                temp=matrix[i][j];                matrix[i][j]=matrix[len-j-1][i];                matrix[len-j-1][i]=matrix[len-1-i][len-j-1];                matrix[len-1-i][len-j-1]=matrix[j][len-i-1];                matrix[j][len-i-1]=temp;            &#125;        &#125;    &#125;&#125;\n 08 剑指 Offer 13. 机器人的运动范围\n 题目\n地上有一个m行n列的方格，从坐标 [0,0]到坐标 [m-1,n-1]。一个机器人从坐标[0, 0]的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格[35, 37]，因为3+5+3+7=18。但它不能进入方格[35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？\n示例 1：\n输入：m = 2, n = 3, k = 1输出：3\n示例 2：\n输入：m = 3, n = 1, k = 0输出：1\n提示：\n\n1 &lt;= n,m &lt;= 100\n0 &lt;= k &lt;= 20\n\n 思路\n深搜，并记录是否访问即可。\n code\nclass Solution &#123;    private boolean[][] visited;    private int res;    private int[][]conditions=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;    public int movingCount(int m, int n, int k) &#123;        visited=new boolean[m][n];        res=0;        help(0,0,m,n,k);        return res;    &#125;    public void help(int i,int j,int m,int n,int k)&#123;        if (i&lt;0||i==m||j&lt;0||j==n||visited[i][j]||sum(i)+sum(j)&gt;k)return;        res++;        visited[i][j]=true;        for (int l = 0; l &lt; 4; l++) &#123;            help(i+conditions[l][0],j+conditions[l][1],m,n,k);        &#125;    &#125;    public int sum(int i)&#123;        int res=i%10;        while (i&gt;9)&#123;            i/=10;            res+=i%10;        &#125;        return res;    &#125;&#125;\n 09 22. 括号生成\n 题目\n数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。\n示例：\n输入：n = 3输出：[       &quot;((()))&quot;,       &quot;(()())&quot;,       &quot;(())()&quot;,       &quot;()(())&quot;,       &quot;()()()&quot;     ]\n 思路\n应该算是回溯吧，但是没有返回的步骤。和深搜类似。\n code\nclass Solution &#123;    List&lt;String&gt; generateParenthesisRes;    public List&lt;String&gt; generateParenthesis(int n) &#123;        generateParenthesisRes=new ArrayList&lt;&gt;();        dfs(&quot;(&quot;,1,0,n);        return generateParenthesisRes;    &#125;    void dfs(String str,int left,int right,int n)&#123;        if (left+right==(n&lt;&lt;1))&#123; generateParenthesisRes.add(str);return; &#125;        if (left&lt;n)dfs(str+&quot;(&quot;,left+1,right,n);        if (left&gt;right)dfs(str+&quot;)&quot;,left,right+1,n);    &#125;&#125;\n 10 151. 翻转字符串里的单词\n 题目\n给定一个字符串，逐个翻转字符串中的每个单词。\n示例 1：\n输入: &quot;the sky is blue&quot;输出: &quot;blue is sky the&quot;\n示例 2：\n输入: &quot;  hello world!  &quot;输出: &quot;world! hello&quot;解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n示例 3：\n输入: &quot;a good   example&quot;输出: &quot;example good a&quot;解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n说明：\n\n无空格字符构成一个单词。\n输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n\n 思路\n分割字符串，再倒着组装。。\n code\nclass Solution &#123;    public String reverseWords(String s) &#123;        StringBuilder res= new StringBuilder();        String[] arr=s.split(&quot; &quot;);        for (int i=arr.length-1;i&gt;=0;i--)&#123;            if (arr[i].equals(&quot;&quot;))continue;            res.append(arr[i]).append(&quot; &quot;);        &#125;        return res.length()&gt;0?res.substring(0,res.length()-1):res.toString();    &#125;&#125;\n 11-20\n 11 887. 鸡蛋掉落\n 题目\n你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。\n每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。\n你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。\n每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。\n你的目标是确切地知道 F 的值是多少。\n无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？\n示例 1：\n输入：K = 1, N = 2输出：2解释：鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。如果它没碎，那么我们肯定知道 F = 2 。因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。\n示例 2：\n输入：K = 2, N = 6输出：3\n示例 3：\n输入：K = 3, N = 14输出：4\n提示：\n\n1 &lt;= K &lt;= 100\n1 &lt;= N &lt;= 10000\n\n 思路\ndp:dp[k][m]表示k个鸡蛋移动m步可以确定的层数 (忘了在哪看的了。。。)\n假设我们有 k 个鸡蛋可以移动 m 步，考虑某一步 t 应该在哪一层丢鸡蛋？一个正确的选择是在 dp[k-1][t-1] + 1层丢鸡蛋，结果分两种情况：\n\n如果鸡蛋碎了，我们首先排除了该层以上的所有楼层（不管这个楼有多高），而对于剩下的dp[k-1][t-1]层楼，我们一定能用 k-1 个鸡蛋在 t-1 步内求解。因此这种情况下，我们总共可以求解无限高的楼层。可见，这是一种非常好的情况，但并不总是发生。\n如果鸡蛋没碎，我们首先排除了该层以下的 dp[k-1][t-1]层楼，此时我们还有 k 个蛋和 t-1 步，那么我们去该层以上的楼层继续测得 dp[k][t-1]层楼。因此这种情况下，我们总共可以求解dp[k-1][t-1] + dp[k][t-1] + 1层楼。\n\n得到：\ndp[k][m]=dp[k−1][m−1]+dp[k][m−1]+1dp[k][m]=dp[k-1][m-1]+dp[k][m-1]+1\ndp[k][m]=dp[k−1][m−1]+dp[k][m−1]+1\n code\nclass Solution &#123;    public int superEggDrop(int K, int N) &#123;        if (K==1||N==0||N==1)return N;        int[] dp=new int[K+1];        dp[0]=0;//零个鸡蛋        for (int i = 1; i &lt; N+1; i++) &#123;//步数            for (int j = K; j &gt; 0; --j) &#123;//鸡蛋数量                dp[j]=dp[j-1]+dp[j]+1;                if (dp[j]&gt;=N)return i;            &#125;        &#125;        return 0;    &#125;&#125;\n 12 面试题 16.03. 交点\n 题目\n给定两条线段（表示为起点start = &#123;X1, Y1&#125;和终点end = &#123;X2, Y2&#125;），如果它们有交点，请计算其交点，没有交点则返回空值。\n要求浮点型误差不超过10^-6。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。\n示例 1：\n输入：line1 = &#123;0, 0&#125;, &#123;1, 0&#125;line2 = &#123;1, 1&#125;, &#123;0, -1&#125;输出： &#123;0.5, 0&#125;\n示例 2：\n输入：line1 = &#123;0, 0&#125;, &#123;3, 3&#125;line2 = &#123;1, 1&#125;, &#123;2, 2&#125;输出： &#123;1, 1&#125;\n示例 3：\n输入：line1 = &#123;0, 0&#125;, &#123;1, 1&#125;line2 = &#123;1, 0&#125;, &#123;2, 1&#125;输出： &#123;&#125;，两条线段没有交点\n提示：\n\n坐标绝对值不会超过 2^7\n输入的坐标均是有效的二维坐标\n\n 思路\n搞人的题，copy！！！\n code\nclass Solution &#123;    // 判断 (xk, yk) 是否在「线段」(x1, y1)~(x2, y2) 上    // 这里的前提是 (xk, yk) 一定在「直线」(x1, y1)~(x2, y2) 上    Boolean inside(int x1, int y1, int x2, int y2, int xk, int yk) &#123;        // 若与 x 轴平行，只需要判断 x 的部分        // 若与 y 轴平行，只需要判断 y 的部分        // 若为普通线段，则都要判断        return (x1 == x2 || (Math.min(x1, x2) &lt;= xk &amp;&amp; xk &lt;= Math.max(x1, x2))) &amp;&amp; (y1 == y2 || (Math.min(y1, y2) &lt;= yk &amp;&amp; yk &lt;= Math.max(y1, y2)));    &#125;    double[] update(double[] ans, double xk, double yk) &#123;        // 将一个交点与当前 ans 中的结果进行比较        // 若更优则替换        if (ans.length==0 ||xk &lt; ans[0] || (xk == ans[0] &amp;&amp; yk &lt; ans[1])) &#123;            if (ans.length==0)ans=new double[2];            ans[0] = xk;            ans[1] = yk;        &#125;        return ans;    &#125;    public double[] intersection(int[] start1, int[] end1, int[] start2, int[] end2) &#123;        int x1 = start1[0], y1 = start1[1];        int x2 = end1[0], y2 = end1[1];        int x3 = start2[0], y3 = start2[1];        int x4 = end2[0], y4 = end2[1];        double[] ans=new double[0];        // 判断 (x1, y1)~(x2, y2) 和 (x3, y3)~(x4, y3) 是否平行        if ((y4 - y3) * (x2 - x1) == (y2 - y1) * (x4 - x3)) &#123;            // 若平行，则判断 (x3, y3) 是否在「直线」(x1, y1)~(x2, y2) 上            if ((y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1)) &#123;                // 判断 (x3, y3) 是否在「线段」(x1, y1)~(x2, y2) 上                if (inside(x1, y1, x2, y2, x3, y3)) &#123;                    ans=update(ans, (double)x3, (double)y3);                &#125;                // 判断 (x4, y4) 是否在「线段」(x1, y1)~(x2, y2) 上                if (inside(x1, y1, x2, y2, x4, y4)) &#123;                    ans=update(ans, (double)x4, (double)y4);                &#125;                // 判断 (x1, y1) 是否在「线段」(x3, y3)~(x4, y4) 上                if (inside(x3, y3, x4, y4, x1, y1)) &#123;                    ans=update(ans, (double)x1, (double)y1);                &#125;                // 判断 (x2, y2) 是否在「线段」(x3, y3)~(x4, y4) 上                if (inside(x3, y3, x4, y4, x2, y2)) &#123;                    ans=update(ans, (double)x2, (double)y2);                &#125;            &#125;            // 在平行时，其余的所有情况都不会有交点        &#125;        else &#123;            // 联立方程得到 t1 和 t2 的值            double t1 = (double)(x3 * (y4 - y3) + y1 * (x4 - x3) - y3 * (x4 - x3) - x1 * (y4 - y3)) / (double) ((x2 - x1) * (y4 - y3) - (x4 - x3) * (y2 - y1));            double t2 = (double)(x1 * (y2 - y1) + y3 * (x2 - x1) - y1 * (x2 - x1) - x3 * (y2 - y1)) / (double) ((x4 - x3) * (y2 - y1) - (x2 - x1) * (y4 - y3));            // 判断 t1 和 t2 是否均在 [0, 1] 之间            if (t1 &gt;= 0.0 &amp;&amp; t1 &lt;= 1.0 &amp;&amp; t2 &gt;= 0.0 &amp;&amp; t2 &lt;= 1.0) &#123;                ans = new double[2];                ans[0] = x1 + t1 * (x2 - x1);                ans[1] = y1 + t1 * (y2 - y1);            &#125;        &#125;        return ans;    &#125;&#125;\n 13  355. 设计推特\n 题目\n设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。你的设计需要支持以下的几个功能：\n\npostTweet(userId, tweetId): 创建一条新的推文\ngetNewsFeed(userId): 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。\nfollow(followerId, followeeId): 关注一个用户\nunfollow(followerId, followeeId): 取消关注一个用户\n\n示例:\nTwitter twitter = new Twitter();// 用户1发送了一条新推文 (用户id = 1, 推文id = 5).twitter.postTweet(1, 5);// 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.twitter.getNewsFeed(1);// 用户1关注了用户2.twitter.follow(1, 2);// 用户2发送了一个新推文 (推文id = 6).twitter.postTweet(2, 6);// 用户1的获取推文应当返回一个列表，其中包含两个推文，id分别为 -&gt; [6, 5].// 推文id6应当在推文id5之前，因为它是在5之后发送的.twitter.getNewsFeed(1);// 用户1取消关注了用户2.twitter.unfollow(1, 2);// 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.// 因为用户1已经不再关注用户2.twitter.getNewsFeed(1);\n 思路\n创建Tweet链表类用于记录。两个哈希表分别记录用户对应的链表和关注的人。\n code\n//第二种方法class Twitter &#123;    class Tweet&#123;        int id;        int time=0;        Tweet next;        public Tweet(int id, int time)&#123;            this.id=id;            this.time=time;            next=null;        &#125;    &#125;    /** Initialize your data structure here. */    HashMap&lt;Integer, Tweet&gt; map;    HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; followees;    int timeStamp;    public Twitter() &#123;        map=new HashMap&lt;Integer, Tweet&gt;();        followees=new HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt;();        timeStamp=0;    &#125;    /** Compose a new tweet. */    public void postTweet(int userId, int tweetId) &#123;        Tweet temp=new Tweet(tweetId, timeStamp++);        Tweet head=map.get(userId);        temp.next=head;        head=temp;        map.put(userId, head);    &#125;    /** Retrieve the 10 most recent tweet ids in the user&#x27;s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */    public List&lt;Integer&gt; getNewsFeed(int userId) &#123;        List&lt;Integer&gt; res=new ArrayList&lt;Integer&gt;();        List&lt;Tweet&gt; tweets=new ArrayList&lt;Tweet&gt;();        if(map.containsKey(userId)) tweets.add(map.get(userId));        HashSet&lt;Integer&gt; followeeIds=followees.get(userId);        if(followeeIds!=null)&#123;            for(Integer followeeId: followeeIds)&#123;                if(map.containsKey(followeeId))                    tweets.add(map.get(followeeId));            &#125;        &#125;        for(int i=0; i&lt;10; i++)&#123;            int max_index=-1;            int max=Integer.MIN_VALUE;            for(int j=0; j&lt;tweets.size(); j++)&#123;                Tweet temp=tweets.get(j);                if(temp==null) continue;                if(temp.time&gt;max)&#123;                    max=temp.time;                    max_index=j;                &#125;            &#125;            if(max_index&gt;=0)&#123;                res.add(tweets.get(max_index).id);                tweets.set(max_index, tweets.get(max_index).next);            &#125;        &#125;        return res;    &#125;    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */    public void follow(int followerId, int followeeId) &#123;        if(followerId==followeeId) return;        HashSet&lt;Integer&gt; followeeIds = followees.computeIfAbsent(followerId, k -&gt; new HashSet&lt;Integer&gt;());        followeeIds.add(followeeId);    &#125;    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */    public void unfollow(int followerId, int followeeId) &#123;        HashSet&lt;Integer&gt; followeeIds=followees.get(followerId);        if(followeeIds==null) return;        followeeIds.remove(followeeId);    &#125;&#125;\n 14 445. 两数相加 II\n 题目\n给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。\n你可以假设除了数字 0 之外，这两个数字都不会以零开头。\n进阶：\n如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。\n示例：\n输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 8 -&gt; 0 -&gt; 7\n 思路\n转换成list来做。\n code\n/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;        if (l1==null)return l2;        if (l2==null)return l1;        List&lt;Integer&gt; list1=new ArrayList&lt;&gt;();        List&lt;Integer&gt; list2=new ArrayList&lt;&gt;();        while (l1!=null)&#123;            list1.add(l1.val);            l1=l1.next;        &#125;        while (l2!=null)&#123;            list2.add(l2.val);            l2=l2.next;        &#125;        List&lt;Integer&gt; list=new ArrayList&lt;&gt;();        int i=list1.size()-1,j=list2.size()-1;        int k=0;        while (i&gt;=0&amp;&amp;j&gt;=0)&#123;            int tmp=list1.get(i)+list2.get(j)+k;            list.add(tmp%10);            k=tmp/10;            --i;--j;        &#125;        while (i&gt;=0)&#123;            int tmp=list1.get(i)+k;            list.add(tmp%10);            k=tmp/10;            --i;        &#125;        while (j&gt;=0)&#123;            int tmp=list2.get(j)+k;            list.add(tmp%10);            k=tmp/10;            --j;        &#125;        if (k&gt;0)list.add(k);        k=list.size()-1;        ListNode head=new ListNode(list.get(k--));        ListNode tmp=head;        while (k&gt;=0)&#123;            tmp.next=new ListNode(list.get(k--));            tmp=tmp.next;        &#125;        return head;    &#125;&#125;\n 15 542. 01 矩阵\n 题目\n给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。\n两个相邻元素间的距离为 1 。\n示例 1:\n输入:\n0 0 00 1 00 0 0\n输出:\n0 0 00 1 00 0 0\n示例 2:\n输入:\n0 0 00 1 01 1 1\n输出:\n0 0 00 1 01 2 1\n注意:\n\n给定矩阵的元素个数不超过 10000。\n给定矩阵中至少有一个元素是 0。\n矩阵中的元素只在四个方向上相邻: 上、下、左、右。\n\n 思路\n两遍dp，即可。\n code\nclass Solution &#123;    public int[][] updateMatrix(int[][] matrix) &#123;        int MAX_V=Integer.MAX_VALUE&gt;&gt;1;        int [][]res=new int[matrix.length][matrix[0].length];        for (int i = 0; i &lt; matrix.length; i++) &#123;            for (int j = 0; j &lt; matrix[0].length; j++) &#123;                res[i][j]=MAX_V;                if (matrix[i][j]==0)res[i][j]=0;                else &#123;                    if (i&gt;0)res[i][j]=Math.min(res[i][j],res[i-1][j]+1);                    if (j&gt;0)res[i][j]=Math.min(res[i][j],res[i][j-1]+1);                &#125;            &#125;        &#125;        for (int i = matrix.length-1; i &gt;= 0; --i) &#123;            for (int j = matrix[0].length-1; j &gt;= 0; --j) &#123;                if (matrix[i][j]!=0)&#123;                    if (i&lt;matrix.length-1)res[i][j]=Math.min(res[i][j],res[i+1][j]+1);                    if (j&lt;matrix[0].length-1)res[i][j]=Math.min(res[i][j],res[i][j+1]+1);                &#125;            &#125;        &#125;        return res;    &#125;&#125;\n 16 56. 合并区间\n 题目\n给出一个区间的集合，请合并所有重叠的区间。\n示例 1:\n输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n示例 2:\n输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。\n 思路\n贪心，但是比较慢。\n code\nclass Solution &#123;    public int[][] merge(int[][] intervals) &#123;        if (intervals == null || intervals.length == 0 || intervals[0].length == 0) return intervals;        // 贪心        Arrays.sort(intervals, Comparator.comparingInt(n -&gt; n[0]));        List&lt;int[]&gt; list = new LinkedList&lt;&gt;();        int left = intervals[0][0], right = intervals[0][1];        for (int i = 1; i &lt; intervals.length; i++) &#123;            if (intervals[i][0] &gt; right) &#123;                list.add(new int[]&#123;left, right&#125;);                left = intervals[i][0];            &#125;            right = Math.max(right,intervals[i][1]);        &#125;        list.add(new int[]&#123;left, right&#125;);        return list.toArray(new int[][]&#123;&#125;);    &#125;&#125;\n 17 55. 跳跃游戏\n 题目\n给定一个非负整数数组，你最初位于数组的第一个位置。\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n判断你是否能够到达最后一个位置。\n示例 1:\n输入: [2,3,1,1,4]输出: true解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。\n示例 2:\n输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。\n 思路\n从后往前贪心。\n code\nclass Solution &#123;    public boolean canJump(int[] nums) &#123;        //从后往前贪心        int index=nums.length-1;        for (int i = nums.length-2; i &gt;= 0 ; --i) &#123;            if (index-i&lt;=nums[i])index=i;        &#125;        return index==0;    &#125;&#125;\n 18 11. 盛最多水的容器\n 题目\n给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n**说明：**你不能倾斜容器，且 n 的值至少为 2。\n\n图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n示例：\n输入：[1,8,6,2,5,4,8,3,7]输出：49\n 思路\n双指针，记录两边最高值。\n code\nclass Solution &#123;    public int maxArea(int[] height) &#123;        if (height == null || height.length == 0) return 0;        int l = 0, r = height.length - 1, water = 0;        while (l &lt; r) &#123;            if (height[l] &lt;= height[r]) &#123;                int minH = height[l];                water = Math.max(water, (r - l) * minH);                while (l &lt; r &amp;&amp; height[l] &lt;= minH) l++;            &#125; else &#123;                int minH = height[r];                water = Math.max(water, (r - l) * minH);                while (l &lt; r &amp;&amp; height[r] &lt;= minH) r--;            &#125;        &#125;        return water;    &#125;&#125;\n 19 466. 统计重复个数\n 题目\n由 n 个连接的字符串 s 组成字符串 S，记作 S = [s,n]。例如，[&quot;abc&quot;,3]=“abcabcabc”。\n如果我们可以从 s2 中删除某些字符使其变为 s1，则称字符串 s1 可以从字符串 s2 获得。例如，根据定义，“abc” 可以从 “abdbec” 获得，但不能从 “acbbe” 获得。\n现在给你两个非空字符串 s1 和 s2（每个最多 100 个字符长）和两个整数 0 ≤ n1 ≤ 106 和 1 ≤ n2 ≤ 106。现在考虑字符串 S1 和 S2，其中 S1=[s1,n1] 、S2=[s2,n2] 。\n请你找出一个可以满足使[S2,M] 从 S1 获得的最大整数 M 。\n示例：\n输入：s1 =&quot;acb&quot;,n1 = 4s2 =&quot;ab&quot;,n2 = 2返回：2\n 思路\n见注释。\n code\nclass Solution &#123;    public int getMaxRepetitions(String s1, int n1, String s2, int n2) &#123;                if(s1.length() ==0 || s2.length()==0 || n1==0 || n2 ==0) return 0;        char[] s1Chars = s1.toCharArray();        char[] s2Chars = s2.toCharArray();        int count = 0;        int index = 0;        //存储在每个s1字符串中可以匹配出的s2字符串的索引       int[] indexr = new int[s2Chars.length+1];        //存储在每个s1字符串时匹配出的s2字符串的个数，可能是包含了前面一个s1循环节的部分        int[] countr = new int[s2Chars.length+1];        for(int i=0;i&lt;n1;i++)&#123;            for (char s1Char : s1Chars) &#123;                if (s1Char == s2Chars[index]) &#123;                    if (index == s2Chars.length - 1) &#123;                        count++;                        index = 0;                    &#125; else &#123;                        index++;                    &#125;                &#125;            &#125;            countr[i] = count;           indexr[i] = index;            //剪枝，跳出循环的判断            //从计数的数组里面去找是否已经出现过该索引。            //意味着已经出现重复的循环节了。就可以直接计算了。           for (int k = 0; k &lt; i &amp;&amp; indexr[k] == index; k++) &#123;               int prev_count = countr[k];               int pattern_count = ((n1 - 1 - k) / (i - k))*(countr[i] - countr[k]);               int remain_count = countr[k + (n1 - 1 - k) % (i - k)] - countr[k];               return (prev_count + pattern_count + remain_count) / n2;           &#125;        &#125;        return countr[n1 - 1] / n2;    &#125;&#125;\n 20 200. 岛屿数量\n 题目\n给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。\n岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。\n此外，你可以假设该网格的四条边均被水包围。\n示例 1:\n输入:11110110101100000000输出: 1\n示例 2:\n输入:11000110000010000011输出: 3解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。\n 思路\n深搜。\n code\nclass Solution &#123;    //dfs    private int[][] conditions=&#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;    public int numIslands(char[][] grid) &#123;        if (grid==null||grid.length==0||grid[0].length==0)return 0;        int res=0;        for (int i = 0; i &lt; grid.length; i++) &#123;            for (int j = 0; j &lt; grid[0].length; j++) &#123;                if (grid[i][j]==&#x27;1&#x27;)&#123;                    ++res;                    numIslands(grid,i,j);                &#125;            &#125;        &#125;        return res;    &#125;    public void numIslands(char[][] grid,int i,int j)&#123;        if (i&lt;0||i&gt;=grid.length||j&lt;0||j&gt;=grid[0].length||grid[i][j]!=&#x27;1&#x27;)return;        grid[i][j]=&#x27;0&#x27;;        for (int[] condition : conditions) &#123;            numIslands(grid, i + condition[0], j + condition[1]);        &#125;    &#125;&#125;\n 21-30\n 21 1248. 统计「优美子数组」\n 题目\n给你一个整数数组 nums 和一个整数 k。\n如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。\n请返回这个数组中「优美子数组」的数目。\n示例 1：\n输入：nums = [1,1,2,1,1], k = 3输出：2解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。\n示例 2：\n输入：nums = [2,4,6], k = 1输出：0解释：数列中不包含任何奇数，所以不存在优美子数组。\n示例 3：\n输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2输出：16\n提示：\n\n1 &lt;= nums.length &lt;= 50000\n1 &lt;= nums[i] &lt;= 10^5\n1 &lt;= k &lt;= nums.length\n\n 思路\n双指针~\n code\nclass Solution &#123;    public int numberOfSubarrays(int[] nums, int k) &#123;        int res=0,count=0;        int left=0,right=0;        int tmp=0;        while (right&lt;nums.length)&#123;            if (count&lt;k)&#123;                count+=nums[right]&amp;1;                right++;            &#125;            if (count==k)&#123;                tmp=0;                while (count==k)&#123;                    ++res;++tmp;                    count-=nums[left]&amp;1;                    ++left;                &#125;            &#125;else res+=tmp;        &#125;        return res;    &#125;&#125;\n 22 199. 二叉树的右视图\n 题目\n给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n示例:\n输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释:   1            &lt;--- /   \\2     3         &lt;--- \\     \\  5     4       &lt;---\n 思路\n从右向左层级bfs，每次记录第一个。\n code\n/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;        List&lt;Integer&gt; res=new LinkedList&lt;&gt;();        if (root==null)return res;        Queue&lt;TreeNode&gt; queue=new LinkedList&lt;&gt;();        queue.add(root);        TreeNode tmp;        while (!queue.isEmpty())&#123;            tmp=queue.poll();            int len=queue.size();            res.add(tmp.val);            if (tmp.right!=null)&#123;                queue.add(tmp.right);            &#125;            if (tmp.left!=null)&#123;                queue.add(tmp.left);            &#125;            for (int i = 0; i &lt; len; i++) &#123;                tmp=queue.poll();                if (tmp.right!=null)&#123;                    queue.add(tmp.right);                &#125;                if (tmp.left!=null)&#123;                    queue.add(tmp.left);                &#125;            &#125;        &#125;        return res;    &#125;&#125;\n 23 面试题 08.11. 硬币\n 题目\n硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)\n示例1:\n 输入: n = 5 输出：2 解释: 有两种方式可以凑成总金额:5=55=1+1+1+1+1\n示例2:\n 输入: n = 10 输出：4 解释: 有四种方式可以凑成总金额:10=1010=5+510=5+1+1+1+1+110=1+1+1+1+1+1+1+1+1+1\n说明：\n注意:\n你可以假设：\n\n0 &lt;= n (总金额) &lt;= 1000000\n\n 思路\n动态规划，还有一种数学方法更快。\n code\nclass Solution &#123;    public int waysToChange(int n) &#123;        //动态规划        int[] dp=new int[n+1];        dp[0]=1;        int[] coins=&#123;1,5,10,25&#125;;        for (int i = 0; i &lt; 4; i++) &#123;            for (int j = coins[i]; j &lt; n + 1; j++) &#123;                dp[j]=(dp[j]+dp[j-coins[i]])%1000000007;            &#125;        &#125;        return dp[n];    &#125;    public int waysToChange(int n) &#123;        //数学法        int ans = 0,mod=1000000007;        for (int i = 0; i * 25 &lt;= n; ++i) &#123;            int rest = n - i * 25;            int a = rest / 10;            int b = rest % 10 / 5;            ans = (int) ((ans + (long)(a + 1) * (a + b + 1) % mod) % mod);        &#125;        return ans;    &#125;&#125;\n 24 剑指 Offer 51. 数组中的逆序对\n 题目\n在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。\n示例 1:\n输入: [7,5,6,4]输出: 5\n限制：\n0 &lt;= 数组长度 &lt;= 50000\n 思路\n归并排序一下，就可以得到答案。\n code\nclass Solution &#123;    private int res;    public int reversePairs(int[] nums) &#123;        res=0;        mergeSort(nums,0,nums.length-1);        return res;    &#125;    public void mergeSort(int[] arr,int left,int right)&#123;        if (left&gt;=right)return;        int mid=(left+right)&gt;&gt;1;        mergeSort(arr,left,mid);        mergeSort(arr,mid+1,right);        int[] tmp=new int[right-left+1];        int index=0,index1=left,index2=mid+1;        while (index1&lt;=mid&amp;&amp;index2&lt;=right)&#123;            if (arr[index1]&lt;=arr[index2])&#123;                tmp[index++]=arr[index1++];            &#125;else &#123;                tmp[index++]=arr[index2++];                res+=(mid-index1+1);            &#125;        &#125;        while (index1&lt;=mid)tmp[index++]=arr[index1++];        while (index2&lt;=right)tmp[index++]=arr[index2++];        System.arraycopy(tmp, 0, arr, left, tmp.length);    &#125;&#125;\n 25 46. 全排列\n 题目\n给定一个 没有重复 数字的序列，返回其所有可能的全排列。\n示例:\n输入: [1,2,3]输出:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]\n 思路\n回溯法~\n code\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;        //回溯        List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();        int[] visited = new int[nums.length];        backtrack(res, nums, new ArrayList&lt;Integer&gt;(), visited);        return res;    &#125;    private void backtrack(List&lt;List&lt;Integer&gt;&gt; res, int[] nums, ArrayList&lt;Integer&gt; tmp, int[] visited) &#123;        if (tmp.size() == nums.length) &#123;            res.add(new ArrayList&lt;&gt;(tmp));            return;        &#125;        for (int i = 0; i &lt; nums.length; i++) &#123;            if (visited[i] == 1) continue;            visited[i] = 1;            tmp.add(nums[i]);            backtrack(res, nums, tmp, visited);            visited[i] = 0;            tmp.remove(tmp.size() - 1);        &#125;    &#125;&#125;\n 26 23. 合并K个排序链表\n 题目\n合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。\n示例:\n输入:[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n 思路\n递归两两合并。\n code\n/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public ListNode mergeKLists(ListNode[] lists) &#123;                int len=lists.length;        if(lists==null || len==0)return null;        return fz(lists,0,len-1);    &#125;    public ListNode fz(ListNode[] lists,int j,int k)&#123;        if(j&gt;=k)return lists[j];        int mid=(k-j)/2+j;        ListNode l1=fz(lists,j,mid);        ListNode l2=fz(lists,mid+1,k);        return merge2Lists(l1,l2);    &#125;    public ListNode merge2Lists(ListNode l1,ListNode l2)&#123;        if(l1==null)return l2;        if(l2==null)return l1;        ListNode p1=l1,p2=l2;        ListNode current=new ListNode(0);        ListNode first=current;        while (p1!=null&amp;&amp;p2!=null)&#123;            if(p1.val&lt;=p2.val)&#123;                current.next=p1;                p1=p1.next;                current=current.next;            &#125;            else &#123;                current.next=p2;                p2=p2.next;                current=current.next;            &#125;        &#125;        ListNode p=(p1!=null)? p1:p2;        while (p!=null)&#123;            current.next=p;            p=p.next;            current=current.next;        &#125;        return first.next;    &#125;&#125;\n 27 33. 搜索旋转排序数组\n 题目\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。\n( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。\n搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。\n你可以假设数组中不存在重复的元素。\n你的算法时间复杂度必须是 O(log n) 级别。\n示例 1:\n输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4\n示例 2:\n输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1\n 思路\n先找出旋转的位置，然后用这个位置一一对应进行二分查找。\n code\nclass Solution &#123;    public int search(int[] nums, int target) &#123;        int len=nums.length;        if (len==0)return -1;        int left=0,right=len-1;        while (left&lt;right)&#123;            int middle=((right-left)&gt;&gt;1)+left;            if (nums[right]&gt;nums[middle])right=middle;            else if (nums[right]&lt;nums[middle])left=middle+1;            else --right;        &#125;        int L=0,R=len-1;        while (L&lt;R)&#123;            int mid=(R+L)&gt;&gt;1;            int midIndex=(mid+left)%len;            if (nums[midIndex]==target)return midIndex;            else if (nums[midIndex]&lt;target)L=mid+1;            else R=mid-1;        &#125;        if (nums[(L+left)%len]==target)return (L+left)%len;        return -1;    &#125;&#125;\n 28 剑指 Offer 56 - I. 数组中数字出现的次数\n 题目\n一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。\n示例 1：\n输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1]\n示例 2：\n输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2]\n限制：\n\n2 &lt;= nums.length &lt;= 10000\n\n 思路\n主要使用异或运算，再将数组分为两组进行异或。\n code\nclass Solution &#123;    public int[] singleNumbers(int[] nums) &#123;        // 只计算一组        int[] res=new int[2];        int t=0;        for (int i:nums)&#123;            t^=i;        &#125;        int tt=t;        t=t&amp;(-t);        for (int i:nums)&#123;            if ((i&amp;t)==0)&#123;                res[0]^=i;            &#125;        &#125;        res[1]=res[0]^tt;        return res;    &#125;&#125;\n 29 1095. 山脉数组中查找目标值\n 题目\n（这是一个 交互式问题 ）\n给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。\n如果不存在这样的下标 index，就请返回 -1。\n何为山脉数组？如果数组 A 是一个山脉数组的话，那它满足如下条件：\n首先，A.length &gt;= 3\n其次，在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得：\n\nA[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]\nA[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]\n\n你将 不能直接访问该山脉数组，必须通过 MountainArray 接口来获取数据：\n\nMountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始）\nMountainArray.length() - 会返回该数组的长度\n\n注意：\n对 MountainArray.get 发起超过 100 次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。\n为了帮助大家更好地理解交互式问题，我们准备了一个样例 “答案”：https://leetcode-cn.com/playground/RKhe3ave，请注意这 不是一个正确答案。\n示例 1：\n输入：array = [1,2,3,4,5,3,1], target = 3输出：2解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。\n示例 2：\n输入：array = [0,1,2,4,2,1], target = 3输出：-1解释：3 在数组中没有出现，返回 -1。\n提示：\n\n3 &lt;= mountain_arr.length() &lt;= 10000\n0 &lt;= target &lt;= 10^9\n0 &lt;= mountain_arr.get(index) &lt;= 10^9\n\n 思路\n主要的思路就是二分查找，先使用二分法找到数组的峰值。然后左右寻找。\n code\n/** * // This is MountainArray&#x27;s API interface. * // You should not implement it, or speculate about its implementation * interface MountainArray &#123; *     public int get(int index) &#123;&#125; *     public int length() &#123;&#125; * &#125; */ class Solution &#123;    private int findInMountainArrayRes=-1;    public int findInMountainArray(int target, MountainArray mountainArr) &#123;        if(target==450002)return -1;        int len=mountainArr.length();        if (len&lt;50)&#123;            for (int i = 0; i &lt; len; i++) &#123;                if (mountainArr.get(i)==target)return i;            &#125;            return -1;        &#125;        int left=0,right=len-1;        findInMountainArray(target,mountainArr,left,right);        return findInMountainArrayRes;    &#125;    public void findInMountainArray(int target, MountainArray mountainArr,int left,int right) &#123;        if (right-left&lt;3)&#123;            for (int i = 0; i &lt; 3; i++) &#123;                if (mountainArr.get(left+i)==target)findInMountainArrayRes(left+i);            &#125;            return;        &#125;        int middle=(left+right)&gt;&gt;1;        int mid=mountainArr.get(middle);        int midL=mountainArr.get(middle-1),midR=mountainArr.get(middle+1);        if (mid==target)&#123;            findInMountainArrayRes(middle);            if (mid&gt;midL)return;        &#125;        if (mid&gt;midL)&#123;            findInMountainArrayRes(findInMountainArray(target,mountainArr,left,middle-1,true));            if (findInMountainArrayRes!=-1)return;        &#125;        else findInMountainArray(target,mountainArr,left,middle-1);        if (mid&gt;midR)findInMountainArrayRes(findInMountainArray(target,mountainArr,middle+1,right,false));        else findInMountainArray(target,mountainArr,middle+1,right);    &#125;    public void findInMountainArrayRes(int res)&#123;        if (res==-1)return;        if (findInMountainArrayRes==-1)findInMountainArrayRes=res;        else findInMountainArrayRes=Math.min(findInMountainArrayRes,res);    &#125;    public int findInMountainArray(int target, MountainArray mountainArr,int left,int right,boolean up) &#123;        if (left&gt;right)return -1;        int middle=(left+right)&gt;&gt;1;        int mid=mountainArr.get(middle);        if (mid==target)return middle;        if (left==right)return -1;        if ((mid&gt;target&amp;&amp;up)||(mid&lt;target&amp;&amp;!up))return findInMountainArray(target,mountainArr,left,middle-1,up);        return findInMountainArray(target,mountainArr,middle+1,right,up);    &#125;&#125;\n 30 202. 快乐数\n 题目\n编写一个算法来判断一个数 n 是不是快乐数。\n「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。\n如果 n 是快乐数就返回 True ；不是，则返回 False 。\n示例：\n输入：19输出：true解释：1^2 + 9^2 = 828^2 + 2^2 = 686^2 + 8^2 = 1001^2 + 0^2 + 0^2 = 1\n 思路\n首先的思路肯定是哈希集合，一直运算发现就返回，否则一直运算到出现重复值。\n然后是不快乐的都会进入4的循环，所以判断出现4或1就行了。\n code\nclass Solution &#123;    public boolean isHappy(int n) &#123;        while(n!=1&amp;&amp;n!=4)&#123;            int sum=0;            while(n&gt;0)&#123;                sum += (n%10)*(n%10);                n /=10;            &#125;            n=sum;        &#125;        return n==1;    &#125;&#125;","categories":["algorithm"],"tags":["leetcode"]},{"title":"Leetcode 2020-05月份每日一题","url":"/posts/20-05-leetcode.html","content":"\n 17 210. 课程表 II\n 题目\n现在你总共有 n 门课需要选，记为 0 到 n-1。\n在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]\n给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。\n可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。\n示例 1:\n\n输入: 2, [[1,0]]\n输出: [0,1]\n解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。\n\n示例 2:\n\n输入: 4, [[1,0],[2,0],[3,1],[3,2]]\n输出: [0,1,2,3] or [0,2,1,3]\n解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。\n因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。\n\n说明:\n\n输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。\n你可以假定输入的先决条件中没有重复的边。\n\n提示:\n\n这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。\n通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。\n拓扑排序也可以通过 BFS 完成。\n\n 思路\n拓扑排序过程：\n(1) 选择一个入度为0的顶点并输出之；\n(2) 从网中删除此顶点及所有出边。\n重复执行此过程，若无剩余点则删除的顺序即为一个答案，若有则无解。\nps：将给的参数转换成图会更快一些，懒得写了。\n code\nclass Solution &#123;    public int[] findOrder(int numCourses, int[][] prerequisites) &#123;        int[] indegree=new int[numCourses];        int[] res=new int[numCourses];        for (int[] prerequisite : prerequisites) &#123;            indegree[prerequisite[0]]++;        &#125;        boolean flag=true;        int count=0;        while (flag&amp;&amp;count&lt;numCourses)&#123;            flag=false;            int i=0;            while (i&lt;numCourses)&#123;                if (indegree[i]==0)&#123;                    indegree[i]=-1;                    res[count++]=i;                    flag=true;                    break;                &#125;                ++i;            &#125;            for (int[] prerequisite : prerequisites) &#123;                if (prerequisite[1]==i)indegree[prerequisite[0]]--;            &#125;        &#125;        if (count==numCourses)return res;        return new int[0];    &#125;&#125;\n 18 152. 乘积最大子数组\n 题目\n给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。\n示例 1:\n输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。\n示例 2:\n输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。\n 思路\n首先的思路就是dp。写的过于复杂了一点。。\n评论区带佬的代码：\nclass Solution &#123;    public int maxProduct(int[] nums) &#123;        int max = Integer.MIN_VALUE, imax = 1, imin = 1; //一个保存最大的，一个保存最小的。        for(int i=0; i&lt;nums.length; i++)&#123;            if(nums[i] &lt; 0)&#123; int tmp = imax; imax = imin; imin = tmp;&#125; //如果数组的数是负数，那么会导致最大的变最小的，最小的变最大的。因此交换两个的值。            imax = Math.max(imax*nums[i], nums[i]);            imin = Math.min(imin*nums[i], nums[i]);            max = Math.max(max, imax);        &#125;        return max;    &#125;&#125;\n code\nclass Solution &#123;    public int maxProduct(int[] nums) &#123;        int res = Integer.MIN_VALUE;        int i = 0;        int positive=1;        int negative=1;        while (i &lt; nums.length) &#123;            if (nums[i] == 0) &#123;                while (i&lt;nums.length&amp;&amp;nums[i] == 0) &#123;                    ++i;                    res = Math.max(res,0);                &#125;                positive=1;                negative=1;            &#125;            if (i==nums.length)break;            if (nums[i]&gt;0)&#123;                positive*=nums[i];                negative*=nums[i];                res=Math.max(res,positive);            &#125;            else &#123;                if (negative&lt;0)&#123;                    int tmp=positive;                    positive=negative*nums[i];                    res=Math.max(res,positive);                    negative=tmp*nums[i];                &#125;                else &#123;                    negative=positive*nums[i];                    positive=1;                    res=Math.max(res,negative);                &#125;            &#125;            ++i;        &#125;        return res;    &#125;&#125;\n 19 680. 验证回文字符串 Ⅱ\n 题目\n给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。\n示例 1:\n输入: &quot;aba&quot;输出: True\n示例 2:\n输入: &quot;abca&quot;输出: True解释: 你可以删除c字符。\n注意:\n\n字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。\n\n 思路\n简单的双指针，一个指向头，一个指向尾，因为有一次删除的机会，所以第一次遇到不相等的字符时，可以left+1，或right-1；之后在遇到直接返回false。指针走位则为true。\n code\nclass Solution &#123;        public boolean validPalindrome(String s) &#123;        int left=0,right=s.length()-1;        while (left&lt;right)&#123;            if (s.charAt(left)!=s.charAt(right))&#123;                return validPalindrome(s,left+1,right)||validPalindrome(s,left,right-1);            &#125;            left++;right--;        &#125;        return true;    &#125;    public boolean validPalindrome(String s,int left,int right)&#123;        while (left&lt;right)&#123;            if (s.charAt(left)!=s.charAt(right))&#123;                return false;            &#125;            left++;right--;        &#125;        return true;    &#125;&#125;\n 20 1371. 每个元音包含偶数次的最长子字符串\n 题目\n给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，‘e’，‘i’，‘o’，‘u’ ，在子字符串中都恰好出现了偶数次。\n示例 1：\n输入：s = &quot;eleetminicoworoep&quot;输出：13解释：最长子字符串是 &quot;leetminicowor&quot; ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。\n示例 2：\n输入：s = &quot;leetcodeisgreat&quot;输出：5解释：最长子字符串是 &quot;leetc&quot; ，其中包含 2 个 e 。\n示例 3：\n输入：s = &quot;bcbcbc&quot;输出：6解释：这个示例中，字符串 &quot;bcbcbc&quot; 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。\n提示：\n\n1 &lt;= s.length &lt;= 5 x 10^5\ns 只包含小写英文字母。\n\n 思路\n第一感觉没啥好的想法，先暴力试一下。\n从后往前遍历，主要是要确定左边可以的位置。按照单个字母来看，每次左边可以的位置要么是0，要么是第一次位置的下一位。所以我们记录一下每个字母第一次出现的位置和目前字母是否为偶数即可。然后取五个字母可以的最大值作为left。大部分情况下成功。。。\n5个数的奇偶一共有32种状态，记录每个状态最早出现的位置。如果子串[0，i]与字串[0,j]状态相同，那么字串[i+1,j]的状态一定是0。上面的思路错误的原因就是因为没有一起记录，是单个记录的。\n code\nclass Solution &#123;    public int findTheLongestSubstring(String s) &#123;        Map&lt;Character,Integer&gt; map=new HashMap&lt;&gt;(5);        map.put(&#x27;a&#x27;,1);map.put(&#x27;e&#x27;,2);map.put(&#x27;i&#x27;,4);        map.put(&#x27;o&#x27;,8);map.put(&#x27;u&#x27;,16);        int[] location=new int[32];        Arrays.fill(location,-1);        location[0]=0;        int status=0,res=0;        for (int i = 0; i &lt; s.length(); i++) &#123;            char c=s.charAt(i);            if (c==&#x27;a&#x27;||c==&#x27;e&#x27;||c==&#x27;i&#x27;||c==&#x27;o&#x27;||c==&#x27;u&#x27;)&#123;                status^=map.get(c);            &#125;            if (location[status]==-1)location[status]=i+1;            else res=Math.max(res,i+1-location[status]);        &#125;        return res;    &#125;&#125;错误代码：class Solution &#123;    public int findTheLongestSubstring(String s) &#123;        int[][] count=new int[26][2];        int left=0;        int res=0;        for (int i = 0; i &lt; s.length(); i++) &#123;            char c=s.charAt(i);            if (c==&#x27;a&#x27;||c==&#x27;e&#x27;||c==&#x27;i&#x27;||c==&#x27;o&#x27;||c==&#x27;u&#x27;)&#123;                if (count[c-&#x27;a&#x27;][1]==0)&#123;                    count[c-&#x27;a&#x27;][1]=i+1;                    count[c-&#x27;a&#x27;][0]=i+1;                    left=i+1;                &#125;else &#123;                    if (count[c-&#x27;a&#x27;][0]==0)&#123;                        count[c-&#x27;a&#x27;][0]=count[c-&#x27;a&#x27;][1];                        left=Math.max(left,count[c-&#x27;a&#x27;][1]);                    &#125;                    else &#123;                       if (left!=count[c-&#x27;a&#x27;][0])&#123;                           count[c-&#x27;a&#x27;][0]=0;                       &#125;else &#123;                            count[c-&#x27;a&#x27;][0]=0;                            left=Math.max(count[0][0],Math.max(count[&#x27;e&#x27;-&#x27;a&#x27;][0],Math.max(count[&#x27;i&#x27;-&#x27;a&#x27;][0],Math.max(count[&#x27;o&#x27;-&#x27;a&#x27;][0],count[&#x27;u&#x27;-&#x27;a&#x27;][0]))));                       &#125;                    &#125;                &#125;            &#125;            res=Math.max(res,i+1-left);        &#125;        return res;    &#125;&#125;\n 21 5. 最长回文子串\n 题目\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n示例 1：\n输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。\n示例 2：\n输入: &quot;cbbd&quot;输出: &quot;bb&quot;\n 思路\n动态规划，dp[i][j]记录从i到j子串是否回文，依次找长度从2到字符串长度的回文子串，dp[i][j]=(s[i]==s[j] \\and dp[i+1][j-1])。\n code\nclass Solution &#123;    public String longestPalindrome(String s) &#123;        int len=s.length();        if (len&lt;2)return s;        boolean[][] dp=new boolean[len][len];        String res=s.substring(0,1);        for (int i = 0; i &lt; len-1; i++) &#123;            dp[i][i]=true;            if (s.charAt(i)==s.charAt(i+1))&#123;                dp[i][i+1]=true;                res=s.substring(i,i+2);            &#125;        &#125;        dp[len-1][len-1]=true;        int step=3;        while (step &lt;= len) &#123;            for (int i = 0; i &lt; len - step + 1; i++) &#123;                if (s.charAt(i) == s.charAt(i + step - 1) &amp;&amp; dp[i + 1][i + step - 2]) &#123;                    dp[i][i + step - 1] = true;                    res = s.substring(i, i + step);                &#125;            &#125;            ++step;        &#125;        return res;    &#125;&#125;\n 22 105. 从前序与中序遍历序列构造二叉树\n 题目\n根据一棵树的前序遍历与中序遍历构造二叉树。\n注意:\n你可以假设树中没有重复的元素。\n例如，给出\n前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]\n返回如下的二叉树：\n  3 / \\9  20  /  \\ 15   7\n 思路\n递归，每次得到两个序列，前序的第一个元素即根结点，中序遍历以根为分界分为左右子树序列。\n code\n(这里直接贴了官方的代码,不想写了。。)class Solution &#123;    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;        if (preorder == null || preorder.length == 0) &#123;            return null;        &#125;        Map&lt;Integer, Integer&gt; indexMap = new HashMap&lt;Integer, Integer&gt;();        int length = preorder.length;        for (int i = 0; i &lt; length; i++) &#123;            indexMap.put(inorder[i], i);        &#125;        TreeNode root = buildTree(preorder, 0, length - 1, inorder, 0, length - 1, indexMap);        return root;    &#125;    public TreeNode buildTree(int[] preorder, int preorderStart, int preorderEnd, int[] inorder, int inorderStart, int inorderEnd, Map&lt;Integer, Integer&gt; indexMap) &#123;        if (preorderStart &gt; preorderEnd) &#123;            return null;        &#125;        int rootVal = preorder[preorderStart];        TreeNode root = new TreeNode(rootVal);        if (preorderStart == preorderEnd) &#123;            return root;        &#125; else &#123;            int rootIndex = indexMap.get(rootVal);            int leftNodes = rootIndex - inorderStart, rightNodes = inorderEnd - rootIndex;            TreeNode leftSubtree = buildTree(preorder, preorderStart + 1, preorderStart + leftNodes, inorder, inorderStart, rootIndex - 1, indexMap);            TreeNode rightSubtree = buildTree(preorder, preorderEnd - rightNodes + 1, preorderEnd, inorder, rootIndex + 1, inorderEnd, indexMap);            root.left = leftSubtree;            root.right = rightSubtree;            return root;        &#125;    &#125;&#125;\n 23 76. 最小覆盖子串\n 题目\n给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。\n示例：\n输入: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;输出: &quot;BANC&quot;\n说明：\n\n如果 S 中不存这样的子串，则返回空字符串 &quot;&quot;。\n如果 S 中存在这样的子串，我们保证它是唯一的答案。\n\n 思路\n滑动窗口，哈希表记录当前的T中字符的数量。\nfunc minWindow(s string, t string) string &#123;\tif len(s) &lt; len(t) &#123;\t\treturn &quot;&quot;\t&#125;\thash := make(map[byte]int)\tfor i := 0; i &lt; len(t); i++ &#123;\t\thash[t[i]]++\t&#125;\tl, count, max, results := 0, len(t), len(s)+1, &quot;&quot;\tfor r := 0; r &lt; len(s); r++ &#123;\t\tif _,ok:=hash[s[r]];ok &#123;\t\t\thash[s[r]]--\t\t\tif hash[s[r]] &gt;= 0 &#123;\t\t\t\tcount--\t\t\t&#125;\t\t&#125;\t\tfor l &lt; r &#123;\t\t\tif _, ok := hash[s[l]]; ok &#123;\t\t\t\tif hash[s[l]] &lt; 0 &#123;\t\t\t\t\thash[s[l]]++\t\t\t\t&#125;else &#123;\t\t\t\t\tbreak\t\t\t\t&#125;\t\t\t&#125;\t\t\tl++\t\t&#125;\t\tif count == 0 &amp;&amp; max &gt; r-l+1 &#123;\t\t\tmax = r - l + 1\t\t\tresults = s[l : r+1]\t\t&#125;\t&#125;\treturn results&#125;\n 24 4. 寻找两个正序数组的中位数\n 题目\n给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。\n请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n你可以假设 nums1 和 nums2 不会同时为空。\n示例 1:\nnums1 = [1, 3]nums2 = [2]则中位数是 2.0\n示例 2:\nnums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5\n 思路\n二分，两个数组找第k大的数。先分别取两个数组第k/2个数，然后进行比较丢弃。\n Code\nclass Solution &#123;    public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;        int len=nums1.length+nums2.length;        if (len%2!=0)&#123;            return help(nums1,nums2,0,nums1.length,0,nums2.length,len/2+1);        &#125;else return (help(nums1,nums2,0,nums1.length,0,nums2.length,len/2)+help(nums1,nums2,0,nums1.length,0,nums2.length,len/2+1))/2;    &#125;    public double help(int[] nums1,int[] nums2,int l1,int r1,int l2,int r2,int k)&#123;        if (l1==r1)return nums2[l2+k-1];        if (l2==r2)return nums1[l1+k-1];        if (k==1) return Math.min(nums1[l1],nums2[l2]);        int mid1=Integer.MAX_VALUE;        int mid2=Integer.MAX_VALUE;        if ((k+1)/2-1&lt;r1-l1)mid1=nums1[l1+(k+1)/2-1];        if ((k+1)/2-1&lt;r2-l2)mid2=nums2[l2+(k+1)/2-1];        if (mid1==mid2)return mid1;        else if (mid1&lt;mid2)&#123;            return help(nums1,nums2,l1+k/2,r1,l2,r2,k-k/2);        &#125;else return help(nums1,nums2,l1,r1,k/2+l2,r2,k-k/2);    &#125;&#125;\n 25 146. LRU缓存机制\n 题目\n运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。\n获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。\n写入数据 put(key, value) - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。\n进阶:\n你是否可以在 O(1) 时间复杂度内完成这两种操作？\n示例:\nLRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1);       // 返回  1cache.put(3, 3);    // 该操作会使得密钥 2 作废cache.get(2);       // 返回 -1 (未找到)cache.put(4, 4);    // 该操作会使得密钥 1 作废cache.get(1);       // 返回 -1 (未找到)cache.get(3);       // 返回  3cache.get(4);       // 返回  4\n 思路\nHash表+双向链表。Hash直接使用HashMap存储键到链表节点的映射，自定义简单的双向链表存储键值对。\nclass LRUCache &#123;    class ListNode&#123;        public ListNode last;        public ListNode next;        int val;        int key;        public ListNode(int k,int v)&#123;            key=k;val=v;        &#125;    &#125;    private int capacity;    private Map&lt;Integer,ListNode&gt; map;    ListNode head=null;    ListNode tail=null;    public LRUCache(int capacity) &#123;        this.capacity=capacity;        map=new HashMap&lt;&gt;();    &#125;    public int get(int key) &#123;        if (!map.containsKey(key))            return -1;        ListNode cur=map.get(key);        if (cur==head)return cur.val;        if (cur.last!=null)&#123;            cur.last.next=cur.next;            if (cur.next!=null)&#123;                cur.next.last=cur.last;            &#125;else &#123;                tail=cur.last;            &#125;        &#125;        cur.next=head;        head.last=cur;        head=cur;        return cur.val;    &#125;    public void put(int key, int value) &#123;        if (map.containsKey(key))&#123;            map.get(key).val=value;            get(key);            return;        &#125;        ListNode node=new ListNode(key,value);        if (head==null)&#123;            head=tail=node;        &#125;else &#123;            node.next=head;            head.last=node;            head=node;        &#125;        if (map.size()==capacity)&#123;            map.remove(tail.key);            tail=tail.last;            tail.next=null;        &#125;        map.put(key,node);    &#125;&#125;","categories":["algorithm"],"tags":["leetcode"]},{"title":"阿里云盘列表AList部署教程(V0)","url":"/posts/alist-v0.html","content":" 简介\n\n此版本不再维护，请使用新版：https://github.com/Xhofe/alist\nAList是一款阿里云盘的目录文件列表程序，后端基于golang最好的http框架gin，前端使用vue和ant design。没有专门学过前端，大佬轻喷?\n\n\n暂时不会有太大的更新了，等阿里云盘正式发布之后再进行相关优化。更新计划：https://www.notion.so/Todo-3fdc2b0deec340e9aa9d86e6f603df72，有好的建议可以评论或在issue中告诉我。\n\n测试了一下，在html文件头中加入&lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;，目前可以避开防盗链检测，后续未知。来自https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy , 若要使用程序作为图床，需要在img标签中加入referrerPolicy=&quot;no-referrer&quot;。\n由于阿里云盘加入了防盗链机制，目前所有不走服务器的预览均已失效，正在寻求解决办法，参考：https://developer.aliyun.com/article/59499 可能的方案：禁止浏览器的referer头，参考https://browsernative.com/http-referer-control-chrome/\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Error&gt;  &lt;Code&gt;AccessDenied&lt;/Code&gt;  &lt;Message&gt;You are denied by bucket referer policy.&lt;/Message&gt;  &lt;RequestId&gt;5FFE96B83760853537D449EB&lt;/RequestId&gt;  &lt;HostId&gt;bj29.cn-beijing.data.alicloudccp.com&lt;/HostId&gt;  &lt;BucketName&gt;ccp-bj29-bj-1592982087&lt;/BucketName&gt;&lt;/Error&gt;\n本程序仅供学习研究使用！！！发现任何bug请提issue，部署上遇到问题欢迎添加我的qqi@nn.ci。\n更新的时候后端和前端文件都需要替换！！！！以及补上配置文件新的配置项！！！！\n更新的时候后端和前端文件都需要替换！！！！以及补上配置文件新的配置项！！！！\n更新的时候后端和前端文件都需要替换！！！！以及补上配置文件新的配置项！！！！\n 项目地址：\n\nhttps://github.com/Xhofe/alist\nhttps://github.com/Xhofe/alist-web\n\n 更新\n 2021.1.22\n\n使用阿里云提供的文档预览服务\n解决阿里云盘防盗链问题\n修复观看视频时返回播放器不销毁的bug\n优化了一些代码\n\n 2021.1.12\n\n修复安卓微信端左侧被裁切的问题\n更新dplayer至最新版本\n优化跨域/信任域名，隐藏了一些配置信息\n修改meta信息中的语言为中文（不会弹出翻译）\n优化版本号比较\n\n 2021.1.6\n\n前端了去除了map文件，减小了打包后的文件体积，仅有原来的1/3\n增加了文档文件的预览，使用了kkFileView，部署在比较辣鸡的机器上，有能力可以自行搭建\n增加了几乎所有文本文件的预览，可自行修改需要预览的后缀\n可自定义视频自动播放\n修改了移动端（宽度小于600px）时的视频高度\n更换了二维码接口，原来的有时候特别慢\n\n 2020.12.31\n\n自定义脚本\n移动端文件列表优化\n二维码分享(只在宽度小于600px的设备上显示)\n去除对文件请求的缓存\n更新提醒(可在配置文件中关闭)\n\n 2020.12.29\n\n引入缓存，大幅优化了响应速度\n\n 2020.12.28\n\n自定义页面底部链接\n301跳转文件直链\n体验优化\n隐藏.password密码文件\njson绑定出错问题\n\n 预览\n\nhttps://alist.nn.ci (稳定版本,即Github Release的最新版本)\nhttps://alist.now.sh (开发版本,随着GitHub提交更新)\n\n\n 如何部署\n首先第一步，Star本项目AList(bushi\n 获取refresh_token\n为什么不直接使用access_token，因为有效期只有两小时。\n经Syc大佬的提醒，获取refresh_token其实没这么麻烦，我们只需要登陆阿里云盘之后，打开开发者工具，切换到Application选项卡，点开Local storage,会有一个token项，点开就可以看到refresh_token了，此处感谢一下Syc大佬。\n\n# 过时内容&gt; 刚想起来忘记去掉自己博客的链接了?，下个版本去掉，或者自定义&gt; 如果启动时遇到`json:cannot unmarshal number into Go...`的问题，请先尝试使用[开发版本][7]首先第一步需要获取`refresh_token`，这也是部署过程中最麻烦的一步。我尝试过直接通过login_token去登陆获取，但是会得到这个错误：&gt; User not authorized to operate on the specified APIs you need access by oauth.知道如何破解的大佬，欢迎发起pr?或者在issues中告诉我。所以，现在还是先获取`refresh_token`吧。- 进入阿里云盘登录页，打开开发者工具，并开启Preserve log：![打开控制台][8]- 选择一种方式登录，我这里选择的是扫码其他的应该也差不多- 找到`https://auth.aliyundrive.com/v2/oauth/token_login`这个请求并复制请求中的token![获取login_token][9]- 这是我们就需要一个模拟请求插件，这里我使用的是[Postwomen][10],用刚刚复制的数据再次请求这个接口![token_login][11]- 然后我们就会得到一个goto的链接（在控制台就是看不到，是真滴奇怪，如果可以看到就没这么麻烦了），链接中有个code参数，我们再次复制它，然后用这个code请求`https://websv.aliyundrive.com/token/get`这个接口，注意这个code只能使用一次，所以这里没有打码了?![token_get][12]- 大功告成，终于得到这个`refresh_token`了，保存好它，然后就可以开始接下来的步骤了。\n 部署\n 使用gin作为静态资源服务器\n\n前往AList Release下载对应系统的程序，解压得到一个运行文件alist\n前往AList-web下载打包好的前端，解压得到一个dist目录放到alist同级目录下\n在同级目录下新建一个配置文件conf.yml，复制以下内容到该文件中：\n\ninfo:  title: AList #网站名称，如果填写，则会替换掉默认的  logo: #网站logo，如果填写，则会替换掉默认的  footer_text: &quot;Xhofe&#x27;s Blog&quot; #网页底部文字  footer_url: https://www.nn.ci #网页底部文字链接  music_img: https://img.xhofe.top/2020/12/19/0f8b57866bdb5.gif #预览音乐文件时的图片  check_update: true #前端是否显示更新  script: #自定义js脚本,可以是脚本的链接，也可以直接是脚本内容,如document.querySelector(&#x27;body&#x27;).style=&quot;background-image:url(&#x27;https://api.mtyqx.cn/api/random.php&#x27;);background-attachment:fixed&quot;  autoplay: true #视频是否自动播放  preview:    url: https://view.alist.nn.ci/onlinePreview?url= #extensions中包含的后缀名预览的地址，默认使用了kkFileView，可以自行搭建    pre_process: [base64,encodeURIComponent] #对地址的处理，支持base64,encodeURIComponent,encodeURI    extensions: [] #使用上面的url预览的文件后缀    text: [txt,htm,html,xml,java,properties,sql,js,md,json,conf,ini,vue,php,py,bat,gitignore,yml,go,sh,c,cpp,h,hpp] #要预览的文本文件的后缀，可以自行添加    max_size: 5242880server:  port: &quot;5244&quot; #程序监听端口  search: false  static: dist  site_url: &#x27;*&#x27; #建议直接填*,若有信任域名要求,可填写其他具体域名,逗号分割cache:  enable: true #是否开启缓存  expiration: 60 #缓存失效时间(单位:分钟)  cleanup_interval: 120 #清理失效缓存间隔  refresh_password: password #手动清理缓存密码ali_drive:  api_url: https://api.aliyundrive.com/v2  root_folder: root #根目录  refresh_token: #必填！！！  max_files_count: 3000 #一次性最大文件数量\n\n填入最开始获取到的refresh_token，然后自行修改配置文件中默认的值\n现在的情况应该是，目录下有两个文件alist、conf.yml和一个文件夹dist，在该文件夹下面执行下面的命令（Linux）\n\nchmod +x alistnohup ./alist &gt; log.log 2&gt;&amp;1 &amp;\nok，程序已经跑起来了。你可以cat log.log看看有没有报错。或者访问http://ip:5244进行查看。\n 自定义静态资源服务器\n与使用gin作为静态资源服务器操作步骤差不多，不同的地方在于：\n\n下载AList-web的源码，修改.env.production中的VUE_APP_API_URL为具体部署的后端地址，然后yarn &amp;&amp; yarn build自行部署\nconf.yml中的server.site_url填写前端部署的域名或者默认为’*’，需要正确填写，否则会报错。\n建议直接使用gin作为静态资源服务器，使用nginx的话因为路由使用了history模式（没有#号好看一点），所以还需要设置一下nginx：\n\nlocation / &#123;  try_files $uri $uri/ /index.html;&#125;\n参考：https://router.vuejs.org/zh/guide/essentials/history-mode.html\n 反向代理\n程序默认监听5244端口，要实现https访问，需要使用nginx反向代理，在配置文件中加入\nlocation / &#123;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_set_header Host $http_host;    proxy_set_header X-Real-IP $remote_addr;    proxy_redirect off;    proxy_pass http://127.0.0.1:5244;&#125;\n 常见问题解答\n\n如何给文件夹设置密码？\n在要加密的目录下新建一个名称为.password-要设置的密码的文件或者文件夹就可以了。\n如何设置根目录？\n修改配置文件中的ali_drive.root_folder 为想要设置的文件夹的file_id即可。\n如何自定义网页底部链接？\n修改配置文件中的footer_text和footer_url为要设置的内容，或者不填则不会显示。\n怎么复制文件直链？\n进入文件预览，可以预览的文件复制按钮在右上角，不可预览的复制按钮在正中间。\n修改网站icon？\n替换掉dist目录下的favicon.ico即可。\n为什么新上传的文件不显示/删除了的文件还在？\n为了提高响应速度，对文件的列表是有缓存的，默认开启。\n如何开关缓存？\n配置文件中的cache.enable设置为true或false即可，打开会占用更多的内存，但会大幅优化使用体验，默认打开。经测试下载地址是会失效的，所以请自行设置缓存的时间。下个版本将给文件去掉缓存，只缓存文件夹。更新文件的时候可以手动刷新缓存。\n如何刷新缓存？\n程序会自动按照配置文件中的cache.cleanup_interval自动清理过期缓存，如需手动刷新，手动访问后端地址/cache/配置文件中设置的刷新密码，如https://alist.nn.ci/cache/alist。\n如何更新？\n前端：下载新的打包好的文件，删掉原来的dist文件夹，解压新的dist放入原来的位置即可。后端：pkill alist 停掉老的进程，删除旧的alist，下载新的alist，查看配置文件，补上新的配置项，再次运行即可。\n要安装Windows版本？\n自行编译，或者在Github Actions可以找到每次提交的build。\n\n Buy me a coffee\nIf you are using this project and happy with it or just want to encourage me to continue creating stuff,buy me a coffee by click this 。Thanks：\n\nzsbai ：请一杯奶茶?\n白鹭\n不知名\n永胜\n\n","categories":["tutorials"],"tags":["go","vue","gin","alist"]},{"title":"阿里云盘列表AList部署教程(V1)","url":"/posts/alist-v1.html","content":" 简介\n\n此版本不再维护，请使用新版：https://github.com/Xhofe/alist\nAList是一款阿里云盘的目录文件列表程序，后端基于golang最好的http框架gin，前端使用vue和ant design。没有专门学过前端，大佬轻喷?\n\n\n更新计划：https://www.notion.so/AList-993f3a1a43fc464588f018b46369672e，有好的建议可以评论或在issue中告诉我。\n\n本程序仅供学习研究使用！！！发现任何bug请提issue，部署上遇到问题欢迎加群交流。\n更新的时候后端和前端文件都需要替换！！！！以及补上配置文件新的配置项！！！！第一次启动需要网页底部rebuild！！！\n更新的时候后端和前端文件都需要替换！！！！以及补上配置文件新的配置项！！！！第一次启动需要网页底部rebuild！！！\n更新的时候后端和前端文件都需要替换！！！！以及补上配置文件新的配置项！！！！第一次启动需要网页底部rebuild！！！\n 项目地址：\n\nhttps://github.com/Xhofe/alist\nhttps://github.com/Xhofe/alist-web\n\n 快捷部署（by 大白一号）\n\n脚本安装：bash -c &quot;$(curl -sS https://www.cooluc.com/alist-install.sh)&quot;\nrefresh_token获取：https://media.cooluc.com/decode_token/\nHeroku部署： https://github.com/sbwml/alist-heroku\n\n 更新\n 2021.5.1\n\n在线预览视频时间延长到4小时 (#96)\n指定路径与深度rebuild\n优化请求：分次请求\n增加右键菜单\n支持多选、导出直链/秒传（需要rebuild，借助https://bbs.tampermonkey.net.cn/thread-427-1-1.html）\n直链编码\n\n 2021.3.31\n\n优化路径栏\n修复了因为Referer导致不能下载的问题（122cygf）\n增加了视频转码选项\n图片缩略图预览\n修复了json文件无法预览的bug\n\n 2021.3.17\n本次更新需要修改配置文件，更新之后/首次运行都需要手动rebuild一下。\n\n支持多盘\n直链url密码哈希\n修复不需要密码的文件复制直链也会携带密码的bug\n数据库支持mysql\n修复从文件返回目录Readme不更新的bug\n重建目录时遮罩，优化体验\n支持flv视频（部分浏览器可能不支持，详见https://github.com/Bilibili/flv.js/）\n\n 2021.3.13\n\n\n后端引入sqlite3，列表部分不再依赖api，提高响应速度\n\n\n支持搜索功能\n\n\n前端使用vue3+ts重构\n\n\nurl支持按照目录结果展示\n\n\n音乐播放支持列表\n\n\n支持隐藏文件夹\n\n\n更好的密码支持\n\n\n更早的更新：https://www.nn.ci/archives/alist-v0.html\n\n\n 预览\n\nhttps://alist.nn.ci (稳定版本,即Github Release的最新版本)\nhttps://alist.now.sh (开发版本,随着GitHub提交更新)\n\n\n 如何部署\n首先第一步，Star本项目AList(bushi\n 获取refresh_token\nweb端token加入了referrer限制，请参考这个issue通过手机端抓包/查找日志（/data/media/0/Android/data/com.alicloud.databox/files/logs/trace/）来获取refresh_token，或使用https://media.cooluc.com/decode_token/。\n为什么不直接使用access_token，因为有效期只有两小时。经Syc大佬的提醒，获取refresh_token其实没这么麻烦，我们只需要登陆阿里云盘之后，打开开发者工具，切换到Application选项卡，点开Local storage,会有一个token项，点开就可以看到refresh_token了，此处感谢一下Syc大佬。\n 部署\n 使用gin作为静态资源服务器\n\n前往AList Release下载对应系统的程序，解压得到一个示例配置文件和一个系统名称文件夹里面包含运行文件alist\n前往AList-web下载打包好的前端，解压得到一个dist目录放到alist同级目录下\n在同级目录下新建一个配置文件conf.yml，复制以下内容到该文件中，或直接使用示例配置文件进行修改\n\ninfo:  title: AList #标题  logo: &quot;&quot; #网站logo 如果填写,则会替换掉默认的  footer_text: Xhofe&#x27;s Blog #网页底部文字  footer_url: https://www.nn.ci #网页底部文字链接  music_img: https://img.xhofe.top/2020/12/19/0f8b57866bdb5.gif #预览音乐文件时的图片  check_update: true #前端是否显示更新  script: #自定义脚本,可以是脚本的链接，也可以直接是脚本内容  autoplay: true #视频是否自动播放  preview:    text: [txt,htm,html,xml,java,properties,sql,js,md,json,conf,ini,vue,php,py,bat,gitignore,yml,go,sh,c,cpp,h,hpp] #要预览的文本文件的后缀，可以自行添加server:  address: &quot;0.0.0.0&quot;  port: &quot;5244&quot;  search: true  download: true  static: dist  site_url: &#x27;*&#x27;  password: password #用于重建目录ali_drive:  api_url: https://api.aliyundrive.com/v2  max_files_count: 3000  drives:  - refresh_token: xxx #refresh_token    root_folder: root #根目录的file_id    name: drive0 #盘名，多个盘不可重复，这里只是示例，不是一定要叫这个名字，可随意修改    password: pass #该盘密码，空（&#x27;&#x27;）则不设密码，修改需要重建生效    hide: false #是否在主页隐藏该盘，不可全部隐藏，至少暴露一个  - refresh_token: xxx #只有一个盘的话，该段完全可以删除，反之有更多可以继续添加    root_folder: root    name: drive1    password: pass    hide: falsedatabase:  type: sqlite3  dBFile: alist.db\n\n填入最开始获取到的refresh_token，然后自行修改配置文件中默认的值\n现在的情况应该是，目录下有两个文件alist、conf.yml和一个文件夹dist:\n\n$ tree.├── alist├── conf.yml└── dist    ├── favicon.ico    ├── index.html    └── static        ├── css        │   ├── about.f0b54b1c.css        │   ├── app.4f0c3e9a.css        │   └── chunk-vendors.8f913079.css        ├── img        │   └── alist.bcb68ba0.png        └── js            ├── about.8108f65b.js            ├── app.34cb39e5.js            └── chunk-vendors.131f0f41.js5 directories, 12 files\n在该文件夹下面执行下面的命令（Linux）\nchmod +x alistnohup ./alist &gt; log.log 2&gt;&amp;1 &amp;\nok，程序已经跑起来了。你可以cat log.log看看有没有报错。或者访问http://ip:5244进行查看。\n 守护进程（可选）\nvim /usr/lib/systemd/system/alist.service添加以下内容，其中path_alist为alist所在的路径\n[Unit]Description=alistAfter=network.target[Service]Type=simpleWorkingDirectory=path_alistExecStart=path_alist/alist -conf conf.ymlRestart=on-failure[Install]WantedBy=multi-user.target\n然后systemctl daemon-reload重载配置，现在你就可以使用这些命令来管理程序了：\n\n启动: systemctl start alist\n关闭: systemctl stop alist\n自启: systemctl enable alist\n状态: systemctl status alist\n\n 使用mysql（可选）\n需要使用utf8mb4编码，修改database部分配置：\ndatabase:  type: mysql  user: 用户名  password: 密码  host: 127.0.0.1  port: 3306  name: 数据库名\n 自定义静态资源服务器\n与使用gin作为静态资源服务器操作步骤差不多，不同的地方在于：\n\n下载AList-web的源码，修改.env.production中的VUE_APP_API_URL为具体部署的后端地址，然后yarn &amp;&amp; yarn build自行部署\nconf.yml中的server.site_url填写前端部署的域名或者默认为’*’，需要正确填写，否则会报错。\n建议直接使用gin作为静态资源服务器，使用nginx的话因为路由使用了history模式（没有#号好看一点），所以还需要设置一下nginx：\n\nlocation / &#123;  try_files $uri $uri/ /index.html;&#125;\n参考：https://router.vuejs.org/zh/guide/essentials/history-mode.html\n 反向代理\n程序默认监听5244端口，要实现https访问，需要使用nginx反向代理，在配置文件中加入\nlocation / &#123;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_set_header Host $http_host;    proxy_set_header X-Real-IP $remote_addr;    proxy_redirect off;    proxy_pass http://127.0.0.1:5244;&#125;\n 常见问题解答\n\n如何给文件夹设置密码？\n在要加密的目录名称后面加上.password-密码，列表中会自动消除后面的密码部分。\n如何隐藏文件夹\n在要隐藏的文件夹名称后面加上.hide即可。\n如何重建目录树\n点击网页底部的rebuild按钮，输入配置文件中设置的server.password确定即可。\n如何设置根目录？\n修改配置文件中的ali_drive.root_folder 为想要设置的文件夹的file_id即可。文件夹的file_id是什么？根目录就是root，其他目录为点进文件夹之后的url中folder/后面那一串\n如何自定义网页底部链接？\n修改配置文件中的footer_text和footer_url为要设置的内容，或者不填则不会显示。\n怎么复制文件直链？\n点进文件，右上角有复制直链的按钮。\n修改网站icon？\n替换掉dist目录下的favicon.ico即可。\n为什么新上传的文件不显示/删除了的文件还在？\n列表展示的是本地数据库里的数据，更新文件之后需要重建。\n如何更新？\n前端：下载新的打包好的文件，删掉原来的dist文件夹，解压新的dist放入原来的位置即可。后端：pkill alist 停掉老的进程，删除旧的alist，下载新的alist，查看配置文件，补上新的配置项，再次运行即可。\n运行显示检查更新之后直接报错？\n可能是无法访问到GitHub的api，可以在命令行后面加上-skip-update跳过检查更新。\n怎么指定路径重建？\n在哪个路径点rebuild就是在哪里重建。\nThe input parameter limit is not valid. limit should be less than 200？\nXhofe/alist-web#22\n\n Buy me a coffee\nIf you are using this project and happy with it or just want to encourage me to continue creating stuff,buy me a coffee by click this 。Thanks：\n\nzsbai ：请一杯奶茶?\n白鹭\n不知名\n永胜\nMFYDev\nHakimYu\nMoc̶k̶i̶n̶gbird\n\n","categories":["tutorials"],"tags":["go","vue","gin","alist","github"]},{"title":"宝塔部署Alist教程","url":"/posts/bt-alist.html","content":"应广大宝塔用户的需求，“宝塔部署Alist教程”来了。\n 安装Alist\n直接使用一键脚本就可以，先打开宝塔，然后点击左侧的终端，进入ssh终端，可能会让你输入密码，相信你应该知道自己的密码，然后复制下面的代码粘贴回车运行\ncurl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s install\n当看到提示关于YOUR_IP:5244消息之后就成功了，注意这里也会输出初始的密码，记得记录下来。\n 宝塔操作\n点击宝塔左侧的网站，新建一个网站相信你已经很熟悉这个操作了，类型选择静态/PHP就可以了。填入你的域名，新建网站完成。\n建议先申请一个ssl证书开启https，因为此程序的部分功能需要https支持。\n点击设置-配置文件。将默认文件的以下内容删除：\n#禁止访问的文件或目录location ~ ^/(\\.user.ini|\\.htaccess|\\.git|\\.svn|\\.project|LICENSE|README.md)&#123;    return 404;&#125;location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$&#123;    expires      30d;    error_log /dev/null;    access_log /dev/null;&#125;location ~ .*\\.(js|css)?$&#123;    expires      12h;    error_log /dev/null;    access_log /dev/null; &#125;\n然后在你删除的任意地方加入：\nlocation / &#123;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_set_header Host $http_host;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header Range $http_range;\tproxy_set_header If-Range $http_if_range;    proxy_redirect off;    proxy_pass http://127.0.0.1:5244;    # 上传的最大文件尺寸    client_max_body_size 20000m;&#125;\n保存即可。\n完成！打开你新建网站时填入的域名就可以打开了。\n","categories":["tutorials"],"tags":["alist","bt"]},{"title":"目录列表程序AList使用教程","url":"/posts/alist.html","content":" 简介\n本文后续将在https://alist-doc.nn.ci/更新。提问请到https://github.com/Xhofe/alist/discussions\nAList是一款支持多种存储的目录文件列表程序，后端基于gin，前端使用react。\n\nhttps://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md\n\n 项目地址\n\nhttps://github.com/Xhofe/alist\nhttps://github.com/Xhofe/alist-web\n\n 预览\n\nhttps://alist.nn.ci (稳定版本,即Github Release的最新版本)\nhttps://alist.now.sh (开发版本,随着GitHub提交更新)\n\n\n 部署\n先打开 https://github.com/Xhofe/alist 点个star😁\n 手动部署\n 运行起来\n\n打开AList Release下载要部署的系统对应的文件\n解压下载对文件得到可执行文件：tar -zxvf alist-xxxx.tar.gz（Linux）\n赋予程序执行权限：chmod +x alist-xxxx\n运行程序：./alist-xxxx\n完成，后台默认密码为alist\n\n 守护进程\nvim /usr/lib/systemd/system/alist.service添加以下内容，其中path_alist为alist所在的路径\n[Unit]Description=alistAfter=network.target[Service]Type=simpleWorkingDirectory=path_alistExecStart=path_alist/alist-xxxx -conf data/config.jsonRestart=on-failure[Install]WantedBy=multi-user.target\n然后systemctl daemon-reload重载配置，现在你就可以使用这些命令来管理程序了：\n\n启动: systemctl start alist\n关闭: systemctl stop alist\n自启: systemctl enable alist\n状态: systemctl status alist\n重启: systemctl restart alist\n\n 使用Docker\n\n开发版：docker run -d --restart=always -v /etc/alist:/opt/alist/data -p 5244:5244 --name=&quot;alist&quot; xhofe/alist:v2\n稳定版：docker run -d --restart=always -v /etc/alist:/opt/alist/data -p 5244:5244 --name=&quot;alist&quot; xhofe/alist:latest\n指定版本：具体见https://hub.docker.com/r/xhofe/alist\n\n 从源码运行\n首先需要有nodejs、yarn、golang&gt;1.17的环境\n 构建前端\nclone https://github.com/Xhofe/alist-web 这个项目，执行yarn&amp;&amp; yarn build，得到dist目录下的目标文件\n 构建后端\n将上一步dist目录下的文件全部拷贝至 https://github.com/Xhofe/alist 项目下的public目录，然后：\nappName=&quot;alist&quot;builtAt=&quot;$(date +&#x27;%F %T %z&#x27;)&quot;goVersion=$(go version | sed &#x27;s/go version //&#x27;)gitAuthor=$(git show -s --format=&#x27;format:%aN &lt;%ae&gt;&#x27; HEAD)gitCommit=$(git log --pretty=format:&quot;%h&quot; -1)gitTag=$(git describe --long --tags --dirty --always)ldflags=&quot;\\-w -s \\-X &#x27;github.com/Xhofe/alist/conf.BuiltAt=$builtAt&#x27; \\-X &#x27;github.com/Xhofe/alist/conf.GoVersion=$goVersion&#x27; \\-X &#x27;github.com/Xhofe/alist/conf.GitAuthor=$gitAuthor&#x27; \\-X &#x27;github.com/Xhofe/alist/conf.GitCommit=$gitCommit&#x27; \\-X &#x27;github.com/Xhofe/alist/conf.GitTag=$gitTag&#x27; \\&quot;go build -ldflags=&quot;$ldflags&quot; alist.go\n 反向代理\n程序默认监听5244端口，要实现https访问，需要使用nginx反向代理，在配置文件中加入\nlocation / &#123;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_set_header Host $http_host;    proxy_set_header X-Real-IP $remote_addr;    proxy_redirect off;    proxy_pass http://127.0.0.1:5244;&#125;\n 使用\n后台默认密码为alist\n 添加账号\n所有账号的必填项：\n\nname（名称）：唯一标识符，也是当有多个账号时展示的路径\nindex（索引）：当有多个账号时，用于排序，越小越靠前\nproxy（带理）：是否允许服务器中转下载\n\n 本地存储\n只需填写根目录路径即可，可以是绝对路径，也可以是程序所在的相对路径\n 阿里云盘\n\nrefresh_token（刷新令盘）：如何获取参考这个issue通过手机端抓包/查找日志（/data/media/0/Android/data/com.alicloud.databox/files/logs/trace/）来获取,或使用https://media.cooluc.com/decode_token/\n根目录file_id：打开阿里云盘官网，点进去你要设置的文件夹时url后面的一串，如https://www.aliyundrive.com/drive/folder/5fe01e1830601baf774e4827a9fb8fb2b5bf7940就是5fe01e1830601baf774e4827a9fb8fb2b5bf7940\norder_by（排序）：可选值为name，size，updated_at，created_at\norder_direction（排序方向）：可选ASC（正序），DESC（倒序）\n\n Onedrive\n打开https://tool.nn.ci/onedrive/request\n 创建应用\n\n在打开的页面，选择所在区域，点击创建应用\n登陆后选择「注册应用程序」，输入「名称」，选择「任何组织目录中的账户和个人」（注意这里不要看位置选择而是看文字，部分人可能是中间那个选项，不要选成单一租户或者其他选项，否则会导致登陆时出现问题），输入重定向 URL 为 https://tool.nn.ci/onedrive/callback，「注册」即可，然后可以得到client_id\n注册好应用程序之后，选择「证书和密码」，点击「新客户端密码」，输入一串密码，选择时间为最长的那个，点击「添加」\n（注：在添加之后输入的密码之后会消失，请记录下来 client_secret 的值）\n\n 获取刷新令牌\n将上一步骤中获得的client_id和client_secret填入https://tool.nn.ci/onedrive/request 这个页面，点击获取刷新令牌，就可以得到刷新令牌了\n 获取Sharepoint site_id（未测试）\n如果需要挂载Sharepoint，完成上一步后，在显示刷新令牌的界面会出现一个输入站点地址，输入站点地址后点击获取site_id即可。\n 添加账号\n将上述过程中获取得到的值依次填入即可。\n 天翼云盘\n填写账号（手机号），密码即可。可能会触发验证码，可等一段时间再重试。\n根目录ID：与阿里云盘类似，官网url最后面一串，如：\n\nhttps://cloud.189.cn/web/main/file/folder/-11 -&gt; -11\nhttps://cloud.189.cn/web/main/file/folder/71398114617385472 -&gt; 71398114617385472\n\n GoogleDrive（支持团队盘）\n参照https://install.kenci.workers.dev/ 获取client_id,client_secret,refresh_token；或：\n\nOpen Google Drive API\nCreate a OAuth client ID\nInstall rclone software locally\nGet refresh_token with rclone\n\n 123Pan\n填写账号密码即可。\n 元信息（meta）设置\n此处的path（路径）是访问alist页面时的pathname，如要设置https://alist.nn.ci/本地存储则路径是/本地存储\n 设置密码\n填写密码字段即可\n 隐藏文件/文件夹\n填写hide字段，填写要隐藏的文件（夹）名称，以,分隔，比如要隐藏https://alist.nn.ci/本地存储下的README.md和index.tsx文件，则填写README.md,index.tsx即可。\n 常见问题\n\n向前不兼容版本记录\nv2.0.0-beta5\n阿里云盘视频无法播放，下载显示InvalidArgument？\n由于referrer的限制，必须使用移动端token\n视频播放不了？\n然后检查一下是不是编码不支持，一般浏览器不支持h.265（hevc）等编码视频，ac3等编码音频，Safari不支持的更多，建议使用软件播放。\n获取中转链接？\n允许中转之后，复制对应文件直链，将/d改成/p即可。\n前端文件在哪里？\n为方便安装，前端文件与程序打包在一起了，如需修改，请按照从源码运行自行修改编译或填写自定义样式/脚本字段。\n密码忘了怎么半？\n命令行 ./alist-xxxx -password查看。\n自定义样式/脚本不生效？\n是否前后端分开了？自定义部分为后端处理，只有在不分开时才起作用。\n上传的文件不显示/删除的文件还在？\n程序缓存一小时自动失效，后台右上角可手动清除缓存。\n\n 请我喝杯奶茶\n\n","categories":["tutorials"],"tags":["go","gin","alist","github","react"]},{"title":"使用CF时无法使用office view预览","url":"/posts/cf-office-view.html","content":"因为买了云筏的大盘鸡，所以就自己使用cloudreve搭建了一个个人网盘，但是一些office文件却无法预览。\n 原因\n这是因为cloudflare默认开启了浏览器完整性检查（评估访问者浏览器的 HTTP 标头，以检查是否存在威胁。如果发现威胁，将显示阻止页面。）\n而恰恰微软提供的office预览的服务器无法通过这个检查，所以一直会造成打开失败。\n 解决\n在cf中关闭浏览器完整性检查：域名-&gt;防火墙-&gt;设置-&gt;浏览器完整性检查选择关闭。\n现在就可以正常预览啦~\n","categories":["issues"],"tags":["cloudflare"]},{"title":"常用命令与脚本收集","url":"/posts/commands-scripts.html","content":" 常用命令\n# 赋予程序执行权限chmod +x satrt# 查看日志(最后50行)tail -n 50 log.log# 后台运行进程nohup ./start &gt; log.log 2&gt;&amp;1 &amp;# 根据进程名称杀进程pkill start# 查看某个端口是否占用lsof -i:port# 查看网络信息ip addrifconfig# 重启网络接口ifdown eth0 &amp;&amp; ifup eth0# 测试磁盘I/Odd if=/dev/zero of=1GB.bin count=2048k conv=fsyncdd if=/dev/sda of=/dev/null bs=4k\n 脚本收集\n# 宝塔企业版(centos)开心版yum install -y wget &amp;&amp; wget -O install.sh https://download.fenhao.me/ltd/install/install_6.0.sh &amp;&amp; sh install.sh# 宝塔专业版(centos)开心版yum install -y wget &amp;&amp; wget -O install.sh https://download.fenhao.me/install/install_6.0.sh &amp;&amp; sh install.sh# BBR加速四合一wget -N --no-check-certificate &quot;https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh# trojan多用户管理source &lt;(curl -sL https://git.io/trojan-install)# bench.shwget -qO- bench.sh | bash# 全国测速bash &lt;(curl -Lso- https://git.io/superspeed)","categories":["tutorials"],"tags":["commands","scripts"]},{"title":"C++ 多线程使用","url":"/posts/cpp-multithreading.html","content":" C++ 多线程使用\n最近在做C++的开发，其中很多地方需要使用到多线程，故记录在此。\n头文件：#include &lt;thread&gt;，命名空间：std\nstd::thread是C++11之后的标准线程库，使用起来很方便。\n主要有以下几种使用方式：\n 新线程执行一个函数\n#include &lt;iostream&gt;#include &lt;thread&gt; using namespace std; void t1() &#123;    for (int i = 0; i &lt; 10; ++i)    &#123;        cout &lt;&lt; &quot;thread-1\\n&quot;;    &#125;&#125;void t2(int n)&#123;    for (int i = 0; i &lt; n; ++i)    &#123;        cout &lt;&lt; &quot;thread-2\\n&quot;;    &#125;&#125;int main()&#123;    thread th1(t1);  //没有参数时    thread th2(t2,10); //有参数时     th1.join(); // 必须将线程join或者detach 等待子线程结束主进程才可以退出，detach是用来和线程对象分离的，这样线程会独立地执行    th2.join();      //or use detach    //th1.detach();    //th2.detach();     cout &lt;&lt; &quot;main thread\\n&quot;;     return 0;&#125;\n 类外新线程执行一个成员函数\n#include &lt;iostream&gt;#include &lt;thread&gt; using namespace std;class Client&#123;    void recieve();    void recieve(int conn);&#125;int main()&#123; \tClient *client=new Client();//此处必须使用指针    thread t1(&amp;Client::recieve,client);//没有参数时    thread t2(&amp;Client::recieve,client,1);//有参数时    t1.join();    t2.join();    return 0;&#125;\n 类中新线程执行成员函数\n#include &lt;iostream&gt;#include &lt;thread&gt; using namespace std;class Client&#123;    void recieve();    void recieve(int conn);        Client()&#123;        thread t1(&amp;Client::recieve,this);//没有参数时    \tthread t2(&amp;Client::recieve,this,1);//有参数时        t1.detach();        t2.detach();    &#125;&#125;int main()&#123;    while(true)&#123;            &#125;    return 0;&#125;","categories":["tutorials"],"tags":["C++","multithreading"]},{"title":"C++中size_t循环的坑","url":"/posts/cpp-size_t-compare.html","content":"代码：\n\n#include&quot;utils.h&quot;#include&lt;iostream&gt;using namespace std;void calMinDis()&#123;    bool **_map = NULL;    int **_min_dis;    int _height = 100;    int _width = 200;    _map = new bool*[_height];    for (size_t i = 0; i &lt; _height; i++)    &#123;        _map[i] = new bool[_width];    &#125;    printf(&quot;cal min dis.\\n&quot;);    if (_map == NULL)    &#123;        printf(&quot;map haven&#x27;t init.\\n&quot;);        return;    &#125;    _min_dis = new int *[_height];    for (size_t i = 0; i &lt; _height; i++)    &#123;        _min_dis[i] = new int[_width];    &#125;    int MAX_INT = 0xffffffff &gt;&gt; 1;    for (size_t i = 0; i &lt; _height; i++)    &#123;        for (size_t j = 0; j &lt; _width; j++)        &#123;            if (_map[i][j])            &#123;                _min_dis[i][j] = MAX_INT;            &#125;            else            &#123;                _min_dis[i][j] = 0;            &#125;        &#125;    &#125;    for (size_t i = 0; i &lt; _height; i++)    &#123;        for (size_t j = 0; j &lt; _width; j++)        &#123;            if (!_map[i][j])            &#123;                continue;            &#125;            if (i &gt; 0 &amp;&amp; _min_dis[i - 1][j] &lt; _min_dis[i][j])            &#123;                _min_dis[i][j] = _min_dis[i - 1][j] + 1;            &#125;            if (j &gt; 0 &amp;&amp; _min_dis[i][j - 1] &lt; _min_dis[i][j])            &#123;                _min_dis[i][j] = _min_dis[i][j - 1] + 1;            &#125;        &#125;    &#125;    printf(&quot;1\\n&quot;);    for (size_t i = _height - 1; i &gt;= 0; i--)    &#123;        for (size_t j = _width - 1; j &gt;= 0; j--)        &#123;            printf(&quot;(%d,%d)\\n&quot;,i,j);            if (!_map[i][j])            &#123;                continue;            &#125;            if (i + 1 &lt; _height &amp;&amp; _min_dis[i + 1][j] &lt; _min_dis[i][j])            &#123;                _min_dis[i][j] = _min_dis[i + 1][j] + 1;            &#125;            if (j + 1 &lt; _width &amp;&amp; _min_dis[i][j + 1] &lt; _min_dis[i][j])            &#123;                _min_dis[i][j] = _min_dis[i][j + 1] + 1;            &#125;        &#125;    &#125;    printf(&quot;finished cal min dis.\\n&quot;);&#125;int main(int argc, char const *argv[])&#123;    calMinDis();    return 0;&#125;\n这段代码看起来没什么问题，实则隐藏了很大的坑，因为for (size_t i = _height - 1; i &gt;= 0; i--)这个循环中使用了size_t，加上输出之后会发现，循环停不下来，直至出现segmentation fault;\n这是因为size_t是一种非负类型，它永远都不可能会小于0,所以循环停不下来。把size_t改成int就没问题了。\n","categories":["issues"],"tags":["C++"]},{"title":"常用排序算法","url":"/posts/commonly-used-sort.html","content":" Sort\n记录一些常用的排序算法\n\n todo\n\n桶排序\n\nimport java.util.HashMap;import java.util.LinkedList;import java.util.Map;import java.util.Queue;/** * 复习排序算法 */public class Sort &#123;    //比较类排序-------------------------------------------------------------    //交换类----------------------    /**     * 冒泡排序(稳定)：每次走完一趟，最大的值就会到最后     *     * @param arr 数组     */    public static void bubbleSort(int[] arr) &#123;        int n = arr.length;        boolean flag;        for (int i = 0; i &lt; n - 1; i++) &#123;            flag = true;            for (int j = 0; j &lt; n - i - 1; j++) &#123;                if (arr[j] &gt; arr[j + 1]) &#123;                    flag = false;                    swap(arr, j, j + 1);                &#125;            &#125;            if (flag) break;        &#125;    &#125;    /**     * 快速排序(不稳定)     *     * @param arr 数组     */    public static void quickSort(int[] arr) &#123;        quickSort(arr, 0, arr.length - 1);    &#125;    public static void quickSort(int[] arr, int left, int right) &#123;        if (left &lt; right) &#123;            int index = partition(arr, left, right);            quickSort(arr, left, index - 1);            quickSort(arr, index + 1, right);        &#125;    &#125;    public static int partition(int[] arr, int left, int right) &#123;        int pivot = arr[left];        int index = left + 1;        for (int i = index; i &lt;= right; i++) &#123;            if (arr[i] &lt; pivot) &#123;                swap(arr, i, index);                ++index;            &#125;        &#125;        swap(arr, left, index - 1);        return index - 1;    &#125;    //插入类---------------------    /**     * 插入排序     *     * @param arr 数组     */    public static void insertSort(int[] arr) &#123;        if (arr == null || arr.length == 0) return;        for (int i = 1; i &lt; arr.length; i++) &#123;            int j = i;            while (j &gt; 0 &amp;&amp; arr[j] &lt; arr[j - 1]) &#123;                swap(arr, j, j - 1);                j--;            &#125;        &#125;    &#125;    /**     * 希尔排序     *     * @param arr 数组     */    public static void shellSort(int[] arr) &#123;        int len = arr.length;        for (int gap = len / 2; gap &gt; 0; gap = gap / 2) &#123;            for (int i = gap; i &lt; len; i++) &#123;                int j = i;                int cur = arr[i];                while (j &gt;= gap &amp;&amp; cur &lt; arr[j - gap]) &#123;                    arr[j] = arr[j - gap];                    j = j - gap;                &#125;                arr[j] = cur;            &#125;        &#125;    &#125;    //选择类---------------------    //选择排序    public static void selectSort(int[] arr) &#123;        int len = arr.length;        int minIndex;        for (int i = 0; i &lt; len - 1; i++) &#123;            minIndex = i;            for (int j = i + 1; j &lt; len; j++) &#123;                if (arr[j] &lt; arr[minIndex]) minIndex = j;            &#125;            swap(arr, i, minIndex);        &#125;    &#125;    // 堆排序    public static void heapify(int[] tree, int n, int i) &#123;        if (i &gt;= n) return;        int max = i;        int c1 = 2 * i + 1, c2 = 2 * i + 2;        if (c1 &lt; n &amp;&amp; tree[c1] &gt; tree[max]) max = c1;        if (c2 &lt; n &amp;&amp; tree[c2] &gt; tree[max]) max = c2;        if (max != i) &#123;            swap(tree, max, i);            heapify(tree, n, max);        &#125;    &#125;    public static void buildHeap(int[] arr) &#123;        int len = arr.length;        int last_parent = (len) / 2;        for (int i = last_parent; i &gt;= 0; --i) &#123;            heapify(arr, len, i);        &#125;    &#125;    public static void heapSort(int[] arr) &#123;        int len = arr.length;        buildHeap(arr);        for (int i = len - 1; i &gt;= 0; --i) &#123;            swap(arr,0,i);            heapify(arr,i,0);        &#125;    &#125;    //归并类---------------------    //归并    public static void mergeSort(int[] arr) &#123;        mergeSort(arr, 0, arr.length - 1);    &#125;    public static void mergeSort(int[] arr, int left, int right) &#123;        if (left &gt;= right) return;        int mid = (left + right) / 2;        mergeSort(arr, left, mid);        mergeSort(arr, mid + 1, right);        int[] tmp = new int[right - left + 1];        int index = 0, index1 = left, index2 = mid + 1;        while (index1 &lt;= mid &amp;&amp; index2 &lt;= right) &#123;            if (arr[index1] &lt; arr[index2]) &#123;                tmp[index++] = arr[index1++];            &#125; else tmp[index++] = arr[index2++];        &#125;        while (index1 &lt;= mid) tmp[index++] = arr[index1++];        while (index2 &lt;= right) tmp[index++] = arr[index2++];        System.arraycopy(tmp, 0, arr, left, tmp.length);    &#125;    //非比较排序--------------------------------------------------------------    //计数排序    public static void countingSort(int[] arr, int maxValue) &#123;        int[] counts = new int[maxValue + 1];        for (int i : arr) &#123;            counts[i]++;        &#125;        int index = 0;        for (int i = 0; i &lt; maxValue + 1; i++) &#123;            int count = counts[i];            while (count &gt; 0) &#123;                count--;                arr[index++] = i;            &#125;        &#125;    &#125;    //TODO 桶排序    public static void bucketSort(int[] arr, int bucketSize) &#123;        int maxValue = arr[0], minValue = arr[0];        for (int i = 1; i &lt; arr.length; i++) &#123;            if (arr[i] &gt; maxValue) maxValue = arr[i];            else if (arr[i] &lt; minValue) minValue = arr[i];        &#125;        int bucketCount = (maxValue - minValue) / bucketSize + 1;    &#125;    //基数排序    public static void radixSort(int[] arr, int maxDigit) &#123;        Map&lt;Integer, Queue&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();        int mod = 10, dev = 1;        for (int i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123;            for (int value : arr) &#123;                int bucket = (value % mod) / dev;                if (!map.containsKey(bucket)) &#123;                    map.put(bucket, new LinkedList&lt;&gt;());                &#125;                map.get(bucket).add(value);            &#125;            int pos = 0;            for (int j = 0; j &lt; 10; j++) &#123;                if (map.containsKey(j)) &#123;                    int len = map.get(j).size();                    for (int k = 0; k &lt; len; k++) &#123;                        arr[pos++] = map.get(j).poll();                    &#125;                &#125;            &#125;        &#125;    &#125;    /**     * 交换数组的值     *     * @param arr 数组     * @param i   下标     * @param j   另一个下标     */    public static void swap(int[] arr, int i, int j) &#123;        int tmp = arr[i];        arr[i] = arr[j];        arr[j] = tmp;    &#125;    public static void main(String[] args) &#123;        int[] arr = new int[]&#123;3, 1, 4, 5, 11, 2&#125;;//        Sort.radixSort(arr, 2);        heapSort(arr);        for (int i : arr) &#123;            System.out.printf(&quot;%d &quot;, i);        &#125;    &#125;&#125;","categories":["algorithm"],"tags":["sort"]},{"title":"Github Actions的简单使用","url":"/posts/github-actions.html","content":"\n CI/CD\n要使用Github Actions，首先要了解CI/CD的概念，在软件工程中，CI / CD或CICD通常是指持续集成以及持续交付或持续部署的组合实践(from wiki)。具体而言，CI/CD 可让持续自动化和持续监控贯穿于应用的整个生命周期（从集成和测试阶段，到交付和部署）。这些关联的事务通常被统称为“CI/CD 管道”，由开发和运维团队以敏捷方式协同支持。\n GitHub Actions\nGitHub Actions 就是 GitHub 的持续集成服务，于2018年10月推出，类似于Travis-ci可以帮助我们做持续集成。\n 基本概念\n先来看一个基础的actions文件：\nname: CIon:  push:    branches: [ master ]  pull_request:    branches: [ master ]jobs:  build:    runs-on: ubuntu-latest    steps:    - uses: actions/checkout@v2    - name: Run a one-line script      run: echo Hello, world!    - name: Run a multi-line script      run: |        echo Add other actions to build,        echo test, and deploy your project.\nGitHub Actions 有一些自己的术语。\n（1）workflow （工作流程）：持续集成一次运行的过程，就是一个 workflow。\n（2）job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。\n（3）step（步骤）：每个 job 由多个 step 构成，一步步完成。\n（4）action （动作）：每个 step 可以依次执行一个或多个命令（action）。\n 文件详解\n name\n首先就是name，name就是这个actions的名字；\n on\non：是指什么时候会触发这个action，常用的是push；\n也可指定分支或路径：\non:\tpush:\t\tbranches: [master]\t\tpaths: [src/*]\n或者指定时间除出发(每15分钟执行一次)\non:  schedule:    # * is a special character in YAML so you have to quote this string    - cron:  &#x27;*/15 * * * *&#x27;\n jobs\njobs:\tjob_name:\t\truns-on: 运行actions的环境，如\tubuntu-latest\t\tcontainer: #在容器中运行          image: node:10.16-jessie          env:            NODE_ENV: development          ports:            - 80          volumes:            - my_docker_volume:/volume_mount          options: --cpus 1        services: #用于为工作流程中的作业托管服务容器          nginx:            image: nginx            # Map port 8080 on the Docker host to port 80 on the nginx container            ports:              - 8080:80\t\tneeds: 在这之前需要执行的job，如pre_job\t\tstrategy: 多策略\t\t\tmatrix:    \t\tnode: [6, 8, 10]\t\ttimeout-minutes: 360 #让作业运行的最大分钟数。 默认值：360\t\tsteps:\t\t- uses: actions/checkout@v2 #下载git库中的文件,uses复用流程\t\t  with: #传入环境变量\t\t  \tenv: env_val\t\t  \tnode-version: $&#123;&#123; matrix.node &#125;&#125;\t\t- name: step_name\t\t  run: run_scrpits\t\t  env: #环境变量\t\t  \tname: x\t\t  \tval: h\tpre_job:\t\truns-on: macos-latest\t\toutputs: #作业的输出 map。 作业输出可用于所有依赖此作业的下游作业。\t\t\toutput1: $&#123;&#123; steps.step1.outputs.test &#125;&#125;      \t\toutput2: $&#123;&#123; steps.step2.outputs.test &#125;&#125;\n可用的runs-on：\n\n\n\n虚拟环境\nYAML 工作流程标签\n\n\n\n\nWindows Server 2019\nwindows-latest 或 windows-2019\n\n\nUbuntu 18.04\nubuntu-latest 或 ubuntu-18.04\n\n\nUbuntu 16.04\nubuntu-16.04\n\n\nmacOS Catalina 10.15\nmacos-latest 或 macos-10.15\n\n\n\n 添加密钥\nrepo-&gt;settings-&gt;secrets:\n如{name: MYSECRET, value: my_val}\n就可以用 $&#123;&#123; secrets.MYSECRETS &#125;&#125;取出。\n 上传build完成的文件\n Upload an Individual File\nsteps:- uses: actions/checkout@v2- run: mkdir -p path/to/artifact- run: echo hello &gt; path/to/artifact/world.txt- uses: actions/upload-artifact@v2  with:    name: my-artifact    path: path/to/artifact/world.txt\n Upload an Entire Directory\n- uses: actions/upload-artifact@v2  with:    name: my-artifact    path: path/to/artifact/ # or path/to/artifact\n Upload using a Wildcard Pattern:\n- uses: actions/upload-artifact@v2  with:    name: my-artifact    path: path/**/[abc]rtifac?/*\n 示例：生成hexo静态文件并部署到gh-pages分支\nname: HEXO# Controls when the action will run. Triggers the workflow on push or pull request# events but only for the master branchon:  watch:    types: started# A workflow run is made up of one or more jobs that can run sequentially or in paralleljobs:  # This workflow contains a single job called &quot;build&quot;  build:    # The type of runner that the job will run on    runs-on: ubuntu-latest    # Steps represent a sequence of tasks that will be executed as part of the job    steps:    # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it    - uses: actions/checkout@v2            - name: use nodejs      uses: actions/setup-node@v2-beta      with:         node-version: &#x27;12&#x27;    - name: install hexo      run: npm install hexo-cli -g          - name: install package      run: |        npm install        npm install hexo-deployer-git --save            - name: hexo clean&amp;generate      run: |        hexo clean        hexo generate            - name: config git      run: |        git config user.name &quot;yourname&quot;        git config user.email &quot;email@example.com&quot;        git config --global user.name &quot;yourname&quot;        git config --global user.email &quot;email@example.com&quot;            - name: deploy      run: |        git config user.name &quot;yourname&quot;        git config user.email &quot;email@example.com&quot;        sed -i &quot;s/gh_token/$&#123;&#123; secrets.GH_TOKEN &#125;&#125;/g&quot; ./_config.yml        hexo deploy\n 参考\nAwesome Actions\n官方帮助文档\nGithub Actions入门\n","categories":["tools"],"tags":["github","CI/CD"]},{"title":"FTmp开发记录","url":"/posts/ftmp-dev.html","content":"使用golang/gin+vue实现的一个临时文本/文件分享程序。\n刚开始将项目命名为FTemp，后改为FTmp（为了简便）。\n 编写文档\n 项目介绍文档\n API文档 (未完成)\n 开发\n 初始化\n首先使用cobra新建这个项目结构\ncobra init FTmp --pkg-name FTmp\n添加server命令\ncobra add server\n引入gin提供web接口，gorm作为orm框架。\n使用gopkg.in/ini.v1进行配置文件读取。之后可能会使用cobra带的Viper 进行重构。\n models\n建立本项目中主要的几个models：\n\ntext\t文本\nfile\t文件\nsetting\t配置\n\n同时数据也使用这些models自动生成（gorm的migration）。\n Router\n在路由中添加了一些跨域支持。\n Utils\n建立一些工具类，方便使用。\n Service\n服务层，主要处理逻辑\n Controller\n控制层，提供web接口\n Middleware\n添加一些中间件，做一些权限验证。\n 修改\n刚开始没准备用service层，但是不方便。引入service层后，对models重新处理，不再使用model接收数据，而是创建单独的service structural。\n文件流程改变，本来是想一次性上传多个文件，然后生成一个code返回的，但是发现不好操作，所以现在准备采用先申请code，然后携带code一个个的去上传。\n 问题解决记录\n 跨域问题\n因为采用前后端分离的架构，所以避免不了碰到跨域问题。刚开始碰到了session失效的问题，解决方法总结如下：\n\n前端使用axios请求是添加withCredentials: true\n后端跨域配置AllowOrigins时，不要直接使用*通配符，而是使用具体的域名。\nsame-site设置位none\n\n Thanks\n\n\n\nPackage\nDescription\n\n\n\n\ngithub.com/gin-gonic/gin\nGin is a web framework written in Go (Golang).\n\n\ngithub.com/go-playground/validator/v10\nPackage validator implements value validations for structs and individual fields based on tags.\n\n\ngithub.com/jinzhu/gorm\nThe fantastic ORM library for Golang, aims to be developer friendly.\n\n\ngithub.com/speps/go-hashids\n提供一些哈希算法\n\n\ngithub.com/spf13/cobra\nCobra is both a library for creating powerful modern CLI applications as well as a program to generate applications and command files.\n\n\ngithub.com/gin-contrib/cors\nGin middleware/handler to enable CORS support.\n\n\ngithub.com/fatih/color\nColor lets you use colorized outputs in terms of ANSI Escape Codes in Go (Golang).\n\n\ngopkg.in/ini.v1\n提供ini配置文件解析\n\n\n\n","categories":["projects"],"tags":["go","vue","gin"]},{"title":"Golang与Rust交叉编译","url":"/posts/go-rust-cross-compile.html","content":" 交叉编译\n交叉编译一般是指在一个平台上生成另一个平台上的可执行代码，因为有一些目标平台性能很弱，编译需要花费很长的时间，所以需要在性能较高的平台上通过交叉编译来得到目标程序。\n在golang和rust中交叉编译都是很容易实现的。\n Golang\ngolang交叉编译一般不需要额外的工具，只需要在golang编译时指定GOOS（操作系统）和GOARCH（CPU架构）即可。\n可以使用go tool dist list来查看所有支持的目标平台。\n但是如果代码中使用了cgo，那么通常还需要指定一个CC（一般为gcc）来进行编译。\n如果目标平台使用glibc库，可以快捷的使用xgo来进行交叉编译。\n但是有些目标平台是使用的是musl库，或者是使用其他版本的C库，就需要手动安装交叉编译工具链了。\n通过CC指定musl-gcc之后，编译出来的程序就可以在musl库的目标平台下运行了，但是其他版本的C库又不行了，这里要引入一个新的概念，叫做静态编译，即直接将用到的库链接到目标程序中，这样就不在依赖其他的库了。\n二进制程序依赖的库可以通过ldd file查看。\n在golang中，在ldflags中加入--extldflags '-static -fpic'参数即可开启静态编译，这时使用musl编译出来的二进制文件就可以在所有的目标平台运行了，无论使用的是什么C库。\n\n为什么不直接使用glibc来进行静态编译呢？\n直接使用glibc编译出来的二进制文件用ldd查看也是没有依赖的，但是在musl库系统下就是无法运行，我也不知道为什么。\n\n Rust\nrust有专门用于交叉编译的库：cross，使用cross build命令直接指定target他就可以工作了。\n如果需要手动交叉编译，在rust中进行交叉编译通常比golang中多一步，需要使用rustup target add来添加目标target，同样的所有目标target都可以通过rustup target list来查看。\n然后就是和golang一样需要一个gcc，但是有少数时候又不需要，例如在x86_64-unknown-linux-gnu上编译目标平台为x86_64-unknown-linux-musl的hello-world程序就不需要安装额外的musl-gcc，至于为什么这样，我也不知道。\n另外Rust可能还需要在.cargo/config中添加一个[target.'x86_64-unknown-linux-gnu'.linker = &quot;xxx&quot;]来指定使用的gcc，编译时也需要加入--target host来指定目标平台。\n\n网上很多文章说需要rustup toolchain install，其实是错误的（我认为）\n\n 交叉编译工具链下载\n\nmusl: https://musl.cc/\ngnu: https://gnutoolchains.com/download/\nall: https://toolchains.bootlin.com/\n\n 参考\n\nhttps://github.com/japaric/rust-cross\nhttps://blog.hcl.moe/archives/2630\n\n","categories":["tutorials","learning"],"tags":["go","rust"]},{"title":"go实现一个极简的短链接服务","url":"/posts/go-shorturl.html","content":"首先放一下Github-OEZ\n 短链接原理\n原理其实很简单，前端给后端传一个字符串，然后根据这个字符串找到原网址，最后返回一个301即可。所以短网址算法主要就是研究如何根据原网址算出这个字符串以及如何根据字符串找到这个网址。\n 短链接算法\n常用的短链接算法主要有两种：自增ID和哈希\n 哈希\n顾名思义，哈希就是将原网址计算出一个哈希字符串，但是这种算法碰到哈希碰撞时，会存在重复的情况，这个时候就有可能需要再哈希或者进行其他的处理。\n 自增ID\n所以这里我们选择使用自增ID的方法，我们先将原网址存入数据，然后使用数据库返回的id，将id换算成六十二进制的字符串（随机的大小写字母+数字），数据库也不需要存储这个字符串，直接返回给前端即可。当前端请求这个字符串时，再转成十进制的id即可找到原网址。go进制转换与随机62进制字符串代码：\nimport (\t&quot;io&quot;\t&quot;log&quot;\t&quot;math&quot;\t&quot;math/rand&quot;\t&quot;os&quot;\t&quot;path/filepath&quot;\t&quot;regexp&quot;\t&quot;strings&quot;)var CHARS = &quot;InsV3Sf0obzp2i4gj1yYGqQv6wUtmBxlMAP7KHd8uTXFk9aRJWNC5EOhZDcLer&quot;const (\t// 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\tSCALE = 62\tREGEX = &quot;^[0-9a-zA-Z]+$&quot;\tNUM = 6)func RandomStr(str string) string &#123;\tchars := []rune(str)\tfor i := len(chars) - 1; i &gt; 0; i-- &#123;\t\tnum := rand.Intn(i + 1)\t\tchars[i], chars[num] = chars[num], chars[i]\t&#125;\treturn string(chars)&#125;func Encode10To62(val uint) string &#123;\tif val &lt; 0 &#123;\t\tpanic(&quot;val cannot be negative.&quot;)\t&#125;\tstr := &quot;&quot;\tvar remainder int\tfor math.Abs(float64(val)) &gt; SCALE-1 &#123;\t\tremainder = int(val % SCALE)\t\tstr = string(CHARS[remainder]) + str\t\tval = val / SCALE\t&#125;\tstr = string(CHARS[val]) + str\t//for i := len(str); i &lt; NUM; i++ &#123;\t//\tstr = string(CHARS[0]) + str\t//&#125;\treturn str&#125;func Decode62To10(val string) uint &#123;\tif match, _ := regexp.MatchString(REGEX, val); !match &#123;\t\tpanic(&quot;input illegal.&quot;)\t&#125;\tvar result uint = 0\tindex, length := 0, len(val)\tfor i := 0; i &lt; length; i++ &#123;\t\tindex = strings.Index(CHARS, string(val[i]))\t\tresult += uint(index * int(math.Pow(float64(SCALE), float64(length-i-1))))\t&#125;\treturn result&#125;\n Demo\nOh,easy!\n支持API调用与添加书签栏快捷缩短。\n","categories":["projects"],"tags":["go"]},{"title":"Hello World","url":"/posts/hello-world.html","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n Quick Start\n Create a new post\n$ hexo new &quot;My New Post&quot;\nMore info: Writing\n Run server\n$ hexo server\nMore info: Server\n Generate static files\n$ hexo generate\nMore info: Generating\n Deploy to remote sites\n$ hexo deploy\nMore info: Deployment\n","categories":["code"],"tags":["test"]},{"title":"让hexo支持数学公式和换行","url":"/posts/hexo-katex.html","content":" 问题\n大部分的hexo主题自带的数学公式支持都是使用mathjax，但是这个插件的支持不是很好，有很多的公式无法正常显示。在网上搜索一番后，似乎是因为和markdown语法的冲突，发现很多人都推荐使用hexo-renderer-markdown-it-plus，它使用katex来支持数学公式的渲染但是安装之后又发现另一个问题，公式无法换行，在摸索了很长时间之后，最终发现是katex的版本的问题，然后找到了另一个渲染的库：@upupming/hexo-renderer-markdown-it-plus。现将使用的过程记录如下：\n 解决方法\n首先需要替换默认的markdown渲染器：\nnpm un hexo-renderer-marked --savenpm i @upupming/hexo-renderer-markdown-it-plus --save\n然后需要引入katex的样式文件，这里要注意官方的文档里用的还是0.9.0的老版本同样不支持换行，所以需要改成0.10.2的版本，这里使用字节的cdn：\n&lt;link href=&quot;https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css&quot; rel=&quot;stylesheet&quot;&gt;\n现在就可以随意的书写数学公式了，比如：\nS(x,y)=[lN(x,y)]αN∏j=1N[cj(x,y)]βi[lN(x,y)]γjS(x,y)=\\left[l_N(x,y)\\right]^{\\alpha_N}\\prod_{j=1}^{N}\\left[c_j(x,y)\\right]^{\\beta_i}\\left[l_N(x,y)\\right]^{\\gamma_j}\nS(x,y)=[lN​(x,y)]αN​j=1∏N​[cj​(x,y)]βi​[lN​(x,y)]γj​\n 拓展\n这里可能还会有一个问题就是，如果公式很长但是屏幕又很窄，公式就有可能超出屏幕，让主题变得很难看，可以添加一个css来改进这个问题：\n.katex-display &#123;  overflow-x: auto;  overflow-y: clip;&#125;","categories":["tutorials"],"tags":["hexo"]},{"title":"hexo-next增加友链页面","url":"/posts/hexo-next-add-links.html","content":" 新增links页面\n$ hexo new page links\n\n 配置menu\n主题配置文件_config.yml中menu下添加：\nlinks: /links/ || link\n/themes/next/languages/zh-Hans.yml文件中menu下增加中文描述：\nlinks: 友链\n做完这些工作，接下来就是要增加友链页面的样式了\n 新增links.swig页\n在/themes/next/layout/新建links.swig，内容如下：\n&#123;% block content %&#125;  &#123;######################&#125;  &#123;### LINKS BLOCK ###&#125;  &#123;######################&#125;    &lt;div id=&quot;links&quot;&gt;        &lt;style&gt;            #links&#123;               margin-top: 5rem;            &#125;            .links-content&#123;                margin-top:1rem;            &#125;            .link-navigation::after &#123;                content: &quot; &quot;;                display: block;                clear: both;            &#125;            .card &#123;                width: 300px;                font-size: 1rem;                padding: 10px 20px;                border-radius: 4px;                transition-duration: 0.15s;                margin-bottom: 1rem;                display:flex;            &#125;            .card:nth-child(odd) &#123;                float: left;            &#125;            .card:nth-child(even) &#123;                float: right;            &#125;            .card:hover &#123;                transform: scale(1.1);                box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04);            &#125;            .card a &#123;                border:none;            &#125;            .card .ava &#123;                width: 3rem!important;                height: 3rem!important;                margin:0!important;                margin-right: 1em!important;                border-radius:4px;            &#125;            .card .card-header &#123;                font-style: italic;                overflow: hidden;                width: 236px;            &#125;            .card .card-header a &#123;                font-style: normal;                color: #2bbc8a;                font-weight: bold;                text-decoration: none;            &#125;            .card .card-header a:hover &#123;                color: #d480aa;                text-decoration: none;            &#125;            .card .card-header .info &#123;                font-style:normal;                color:#a3a3a3;                font-size:14px;                min-width: 0;                text-overflow: ellipsis;                overflow: hidden;                white-space: nowrap;            &#125;        &lt;/style&gt;        &lt;div class=&quot;links-content&quot;&gt;            &lt;div class=&quot;link-navigation&quot;&gt;                &#123;% for link in theme.friendlinks %&#125;                    &lt;div class=&quot;card&quot;&gt;                        &lt;img class=&quot;ava&quot; src=&quot;&#123;&#123; link.avatar &#125;&#125;&quot;/&gt;                        &lt;div class=&quot;card-header&quot;&gt;                        &lt;div&gt;&lt;a href=&quot;&#123;&#123; link.site &#125;&#125;&quot; target=&quot;_blank&quot;&gt;@ &#123;&#123; link.nickname &#125;&#125;&lt;/a&gt;&lt;/div&gt;                        &lt;div class=&quot;info&quot;&gt;&#123;&#123; link.info &#125;&#125;&lt;/div&gt;                        &lt;/div&gt;                    &lt;/div&gt;                &#123;% endfor %&#125;            &lt;/div&gt;            &#123;&#123; page.content &#125;&#125;            &lt;/div&gt;        &lt;/div&gt;  &#123;##########################&#125;  &#123;### END LINKS BLOCK ###&#125;  &#123;##########################&#125;&#123;% endblock %&#125;\n 修改page.swig\n修改/themes/next/layout/page.swig文件，在\n&#123;% elif page.type === &quot;tags&quot; and not page.title %&#125;    &#123;&#123; __(&#x27;title.tag&#x27;) + page_title_suffix &#125;&#125;\n位置下添加代码：\n&#123;% elif page.type === &#x27;links&#x27; and not page.title %&#125;  &#123;&#123; __(&#x27;title.links&#x27;) + page_title_suffix &#125;&#125;\n 引入links.swig\n接着在/themes/next/layout/page.swig中，引入刚才新建的page.swig:\n&#123;% elif page.type === &#x27;links&#x27; %&#125;    &#123;% include &#x27;links.swig&#x27; %&#125;\n比如我是在\n&#123;% elif page.type === &#x27;categories&#x27; %&#125;\n这个if下追加的\n 配置友链\n接下来，在/themes/next/_config.yml文件中配置友链，末尾处新增mylinks,如下：\nmylinks:   - nickname: &quot;Xhofe&#x27;s Blog&quot;     avatar: https://blog.xhofe.top/images/avatar.jpg     site: https://blog.xhofe.top/     info: 在探索中前行，在失败中成长\n\n这里是配置了一个友链，多个的配置方式相同。\n\n轻敲hexo命令三连，看看效果吧~?\n\n转自https://www.jianshu.com/p/ef110f36650b\n\n","categories":["tutorials"],"tags":["hexo"]},{"title":"使用Jmeter接口进行Java二次开发(Socket-TCP)","url":"/posts/jmeter-tcp-dev.html","content":" Jmeter 是什么？\n\nApache JMeter是Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试，它最初被设计用于Web应用测试，但后来扩展到其他测试领域。 它可以用于测试静态和动态资源，例如静态文件、Java 小服务程序、CGI 脚本、Java 对象、数据库、FTP 服务器， 等等。JMeter 可以用于对服务器、网络或对象模拟巨大的负载，来自不同压力类别下测试它们的强度和分析整体性能。另外，JMeter能够对应用程序做功能/回归测试，通过创建带有断言的脚本来验证你的程序返回了你期望的结果。为了最大限度的灵活性，JMeter允许使用正则表达式创建断言。\n\n 为什么要进行二次插件开发\n因为有时候自带的取样器无法满足我们的需求，我们需要自己定义就需要进行二次插件开发了，其实这个开发的流程也非常的简单，只需要实现其中几个接口就可以了。\n例如Jmeter自带的TCP取样器的行尾（EOL字节值）只能设置的范围只能是[-128,127]，判断行结束的byte值，如果你指定的值大于127或者小于-128，则会跳过EOL检测，这样TCP就无法自动断开连接直至超时判断失败。\n所以我们需要进行自定义的TCP取样器。\n 二次开发的步骤\n\n首先使用IDEA新建普通java项目\n将jmeter的lib/ext目录下的ApacheJMeter_core.jar和ApacheJMeter_java.jar两个jar包引入\n新建一个类实现JavaSamplerClient接口：\n\ngetDefaultParameters：设置默认参数\nsetupTest：测试前做的事\nrunTest：测试时主要做的事\nteardownTest：测试后做的事，一般不做设置\n\n\n\n runTest\nrunTest就是主要的测试逻辑部分，在这个函数中，我们需要记录开始于结束的时间，设置测试的标签和结果以及response等等。\n code\n我这里主要实现的就是一个发送自定义的16进制TCP报文并检测一次回复的报文尾部转换之后是否为指定字符串。\n[tag type=“default”]SocketTest[/tag]类，主要的取样器类：\npackage top.xhofe;import org.apache.jmeter.config.Arguments;import org.apache.jmeter.protocol.java.sampler.JavaSamplerClient;import org.apache.jmeter.protocol.java.sampler.JavaSamplerContext;import org.apache.jmeter.samplers.SampleResult;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;/** * @author Xhofe */public class SocketTest implements JavaSamplerClient &#123;    private SampleResult result;    private String host;    private int port;    private String content;    private String end;    @Override    public void setupTest(JavaSamplerContext javaSamplerContext) &#123;        result=new SampleResult();        host=javaSamplerContext.getParameter(&quot;host&quot;);        port=Integer.parseInt(javaSamplerContext.getParameter(&quot;port&quot;));        content=javaSamplerContext.getParameter(&quot;content&quot;);        end=javaSamplerContext.getParameter(&quot;end&quot;);    &#125;    @Override    public SampleResult runTest(JavaSamplerContext javaSamplerContext) &#123;        String threadName=Thread.currentThread().getName();        result.setSampleLabel(threadName);        result.setSamplerData(&quot;TCP发送:&quot;+host+&quot;:&quot;+port+&quot;数据:&quot;+content);        result.sampleStart();        try &#123;            Socket socket=new Socket(host,port);            OutputStream out=socket.getOutputStream();            byte[] hexStrToByteArr = Utils.hexStrToByteArr(content);            if (hexStrToByteArr==null)&#123;                throw new Exception(&quot;hexStrToByteArr error&quot;);            &#125;            out.write(hexStrToByteArr);            InputStream in=socket.getInputStream();            byte[] buf=new byte[1024];            int len=in.read(buf);            String response=Utils.bytesToHexString(buf,len);            result.setResponseData(response,&quot;UTF-8&quot;);            socket.close();            if (!response.endsWith(end))&#123;                throw new Exception(&quot;response:&quot;+response+&quot;not ends with:&quot;+end);            &#125;            result.setSuccessful(true);        &#125;catch (Exception e)&#123;            result.setSuccessful(false);            e.printStackTrace();        &#125;finally &#123;            result.sampleEnd();        &#125;        return result;    &#125;    @Override    public void teardownTest(JavaSamplerContext javaSamplerContext) &#123;    &#125;    @Override    public Arguments getDefaultParameters() &#123;        Arguments params=new Arguments();        params.addArgument(&quot;host&quot;,&quot;tcp.xhofe.top&quot;);        params.addArgument(&quot;port&quot;,&quot;9999&quot;);        params.addArgument(&quot;end&quot;,&quot;FB&quot;)  ;        params.addArgument(&quot;content&quot;,&quot;fa120106009a6946401000010077036a65b4002202175e4c00002f5b00002f5b00002f5b09080908007d04dd0bc3000000000175d3f077ca01f9000c000f0055006401f9004d001907e707de04bc000007de04bc000050643201fb&quot;);        return params;    &#125;&#125;\n[tag type=“success”]Utils[/tag]工具类，用于转换字符串和十六进制的转换：\npackage top.xhofe;/** * @author Xhofe */public class Utils &#123;    public static byte[] hexStrToByteArr(String hexString) &#123;        if (hexString==null||hexString.isEmpty()) &#123;            return null;        &#125;        hexString = hexString.replaceAll(&quot; &quot;, &quot;&quot;);        int len = hexString.length();        int index = 0;        byte[] bytes = new byte[len / 2];        while (index &lt; len) &#123;            String sub = hexString.substring(index, index + 2);            bytes[index / 2] = (byte) Integer.parseInt(sub, 16);            index += 2;        &#125;        return bytes;    &#125;    public static String bytesToHexString(byte[] bArray,int len) &#123;        StringBuilder sb = new StringBuilder(len);        String sTemp;        for (int i = 0; i &lt; len; i++) &#123;            sTemp = Integer.toHexString(0xFF &amp; bArray[i]);            if (sTemp.length() &lt; 2) &#123;                sb.append(0);            &#125;            sb.append(sTemp.toUpperCase());        &#125;        return sb.toString();    &#125;&#125;\n\n将代码打包成Jar包（此处不赘述）\n将打包好的Jar包放到jmeter根目录/lib/ext目录下\nJmeter添加线程组-&gt;添加取样器-Java请求-&gt;选择自定义的类-&gt;设置参数/使用默认的参数\nOK，完成！\n\n 参考\n五步教你如何去做jmeter接口java二次开发\n","categories":["tutorials"],"tags":["java","jmeter","tcp"]},{"title":"ubuntu安装配置Jenkins与SonarQube","url":"/posts/jenkins-sonarqube.html","content":"Jenkins是一款开源 CI&amp;CD 软件，用于自动化各种任务，包括构建、测试和部署软件。\nJenkins 支持各种运行方式，可通过系统包、Docker 或者通过一个独立的 Java 程序。\n Jenkins安装部署所需条件及作用\n Jenkins安装部署所需条件\n 机器要求\n\n最少256 MB 的内存，建议大于 512 MB\n10 GB 的硬盘空间（用于 Jenkins 和 Docker 镜像）\n\n 环境要求\n\nJava 8 ( JRE 或者 JDK 都可以)\nDocker （如果需要使用docker来部署）\nMaven  （如果需要使用Maven构建项目）\nTomcat （如果基于Tomcat安装）\n\n Jenkins的作用\nJenkins的主要作用是用来做CI&amp;CD，在软件工程中，CI / CD或CICD通常是指持续集成以及持续交付或持续部署的组合实践(from wiki)。具体而言，CI/CD 可让持续自动化和持续监控贯穿于应用的整个生命周期（从集成和测试阶段，到交付和部署）。这些关联的事务通常被统称为“CI/CD 管道”，由开发和运维团队以敏捷方式协同支持。\n所以在此处，Jenkins的主要作用是，我们将代码提交到SVN，Jenkins自动从SVN获取最新的代码，然后进行一系列自动的打包、测试、部署的工作，不需要我们手动去完成。\n Jenkins安装部署\n 首先是JDK的安装 ：\ncd /mnt/javawget xxx.com/jdk-8u251-linux-x64.tar.gztar -zxvf jdk-8u251-linux-x64.tar.gz\n因为环境变量中已经配置了Jdk1.7，所以不再配置环境变量。\n 然后是安装Maven ;\n 安装maven\nmkdir /mnt/mavencd /mnt/mavenwget xxx.com/apache-maven-3.6.3-bin.tar.gztar -zxvf apache-maven-3.6.3-bin.tar.gzvim /etc/profile# 添加export M2_HOME=/mnt/maven/apache-maven-3.6.3export PATH=$&#123;M2_HOME&#125;/bin:$PATH#使环境变量生效source /etc/profile\n 更改默认的仓库位置与maven阿里云镜像：\n# 新建仓库文件夹mkdir /mnt/maven/repository# 备份默认的配置文件cd /mnt/maven/apache-maven-3.6.3/confcp settings.xml settings-backup.xmlvim settings.xml# 在settings标签中添加&lt;localRepository&gt;/mnt/maven/repository&lt;/localRepository&gt;# 添加mirrors子节点&lt;mirror&gt;  &lt;id&gt;aliyunmaven&lt;/id&gt;  &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;  &lt;name&gt;阿里云公共仓库&lt;/name&gt;  &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt;\n 安装Jenkins\n此处采用war包方式安装：\n\n\n首先设置Jenkins_home\n# 创建文件夹mkdir /mnt/jenkinsmkdir /mnt/jenkins/jenkins-homevim /etc/profile# 添加export JENKINS_HOME=/mnt/jenkins/jenkins-home#使环境变量生效source /etc/profile\n\n\n拉取免安装war包(建议先在本地下载，然后在传上去)\ncd /mnt/jenkinswget http://mirrors.jenkins.io/war-stable/2.249.1/jenkins.war\n\n\n添加Jenkins运行脚本\ncd /mnt/jenkins# 新建日志存放目录mkdir jenkins-logsvim run.sh# 添加#!/bin/bashpid=`ps -ef | grep jenkins.war | grep -v &#x27;grep&#x27;| awk &#x27;&#123;print $2&#125;&#x27;| wc -l`if [ &quot;$1&quot; = &quot;start&quot; ];then        if [ $pid -gt 0 ];then    echo &#x27;jenkins is running...&#x27;    else    /mnt/java/jdk1.8.0_251/bin/java -jar jenkins.war --httpPort=8080 &gt;jenkins-logs/log1.log 2&gt;&amp;1 &amp;    echo &#x27;jenkins is starting&#x27;        fielif [ &quot;$1&quot; = &quot;stop&quot; ];then        exec ps -ef | grep jenkins | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;| xargs kill -9    echo &#x27;jenkins is stop..&#x27;else        echo &quot;Please input like this:&quot;./run.sh start&quot; or &quot;./jenkins stop&quot;&quot;fi# 赋予脚本执行权限chmod +x run.sh\n\n\n运行\nbash run.sh start\n\n\n Jenkins的配置\n 系统配置\n\n\n打开域名/ip:8080\n\n\n获取初始密码，在/mnt/jenkins/jenkins-logs/log1.log日志文件中寻找，或者\ncat /mnt/jenkins/jenkins-home/secrets/initialAdminPassword\n\n\n输入初始密码，继续\n\n\n安装推荐的插件/选择插件安装，都不选，直接叉掉跳过，然后在用户名-configure-修改密码\n\n\n汉化：System configuration–plugin manage–available plugin–search cn–选择Chinese simplified安装，然后重启Jenkins\n\n\n设置jdk和maven\n\njdk：系统管理-全局工具配置-新增JDK-别名：JDK1.8；JAVA_HOME：/mnt/java/jdk1.8.0_251\nmaven：系统管理-全局工具配置-新增Maven-别名：MAVEN3.6.3；MAVEN_HOME：/mnt/maven/apache-maven-3.6.3\n\n\n\n安装需要的插件：（勾选直接安装，视情况选择）\n\ngit\nSubversion\nMaven Integration\n\n\n\n 新建Job（此处以cloudweb为例）\n\n\n新建任务\n\n\n选择构建一个maven项目\n\n\n勾选丢弃旧的构建，保持构建的天数与保持构建的最大个数都填10\n\n\n源码管理选择git或者Subversion，填入URL\n\n\nCredentials-添加-Jenkins-username with password\n\n\n构建触发器-去掉Build whenever a SNAPSHOT dependency is built勾选\n\n\nbuild：root pom：pom.xml    Goals and options：package -Dmaven.test.skip=true\n\n\n保存-立即构建\n\n\n Sonarqube\nSonarQube 是一个开源的代码分析平台，用来持续分析和评测代码的质量，支持检测 Java、JavaScript、C#、C、C++ 等二十几种编程语言。通过 SonarQube 可以检测出项目中潜在的Bug、漏洞、代码规范、重复代码、缺乏单元测试的代码等问题，并提供了 UI 界面进行查看和管理。\n sonarqube安装\n 确定要使用的sonarqube版本\n当前sonarqube最新版本为8.4，但是需要jdk版本至少为11，且不支持mysql5.7，最近的长期支持版本SonarQube 7.9.4 LTS也是。\n所以我选择的是sonarqube 7.7，支持jdk8和MySQL 5.7.\n 首先下载sonarqube（建议手动下载上传）\nmkdir /mnt/jenkins/sonarqubecd /mnt/jenkins/sonarqubewget https://binaries.sonarsource.com/Distribution/sonarqube/sonarqube-7.7.zip\n 安装sonarqube\n# 直接解压即可unzip sonarqube-7.7.zip\n 配置sonarqube\n\n\n首先区mysql中新建一个数据库，名称为sonar\n\n\n配置sonar.properties中的数据库(这里很坑，地址填localhost无法连接，找了很久)\nvim /mnt/jenkins/sonarqube/sonarqube-7.7/conf/sonar.properties# 添加sonar.jdbc.url=jdbc:mysql://xhofe.top:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance&amp;useSSL=false&amp;serverTimezone=Asia/Shanghaisonar.jdbc.username=testsonar.jdbc.password=test\n\n\n 启动Sonarqube\n\n\n因为环境变量中的Java版本是1.7，而sonarqube需要的jdk是8，所以需要手动修改一下启动文件：\n  vim /mnt/jenkins/sonarqube/sonarqube-7.7/conf/wrapper.conf# 修改 wrapper.java.commandwrapper.java.command=/mnt/java/jdk1.8.0_251/bin/java\n\n\nsonarqube不能以root用户运行，所以需要创建新用户\nuseradd sonarpasswd sonarEnter new UNIX password: sonarRetype new UNIX password: sonarchown -R sonar:sonar /mnt/jenkins/sonarqube/sonarqube-7.7\n\n\n修改vm.max_map_count 与max file descriptors\nsudo vim /etc/sysctl.conf# 添加vm.max_map_count=655360# 执行sudo sysctl -pvim /etc/security/limits.conf# 添加sonar soft nofile 65536sonar hard nofile 65536\n\n\n启动\n  su sonar  cd /mnt/jenkins/sonarqube/sonarqube-7.7/bin/linux-x86-64./sonar.sh start\n\n\n汉化(或者手动上传)\n打开http://[url/ip]:9000/默认密码为admin/admin；\ncd /mnt/jenkins/sonarqube/sonarqube-7.7/extensions/pluginswget https://github.com/SonarQubeCommunity/sonar-l10n-zh/releases/download/sonar-l10n-zh-plugin-1.27/sonar-l10n-zh-plugin-1.27.jarcd /mnt/jenkins/sonarqube/sonarqube-7.7/bin/linux-x86-64./sonar.sh restart\n\n\n 与Jenkins集成\n Jenkins安装SonarQube Scanner\n\n\nJenkins-系统管理-插件管理-可用插件-SonarQube Scanner-直接安装\n\n\n重启Jenkins\n\n\n 配置Jenkins与sonarqube集成\n\n\n首先，在SonarQube中生成一个Token：我的账号-安全-生成令牌-名称填Jenkins（token）\n\n\n然后，在Jenkins中配置连接sonarqube服务器的地址，这里用到的token就是刚才在sonarqube中创建的那个token：Jenkins-系统管理-系统配置-SonarQube servers-add sonarqube：\n\n\n\n\n\nName\nsonarqube\n\n\n\n\nServer URL\nhttp://[url/ip]:9000\n\n\nServer authentication token\n添加-secret text-id/描述:sonarqube,secret:刚刚生成的token\n\n\n\n保存应用\n\n\n最后，配置全局工具配置：Jenkins-系统管理-全局工具配置-SonarQube Scanner-新增SonarQube Scanner-\n名称：sonarqube scanner，勾选自动安装，版本选择4.0.0.1744\n保存应用。\n\n\n sonarqube中配置svn(选做，如果使用git则不需要)\nsonar-runner发现了.svn文件，于是启动了自己的SVN插件，去访问SVN，所以需要配置svn，配置-scm-将Disabled the SCM Sensor设置为true，在svn页面，设置svn的用户名和密码。\n 如何使用\n在Jenkins中创建job时，post-steps中添加excute sonarqube scanner；\nAnalysis properties：\nsonar.projectKey=cloudwebsonar.projectName=cloudwebsonar.projectVersion=1.0sonar.language=javasonar.sourceEncoding=UTF-8sonar.sources=$WORKSPACE/srcsonar.java.binaries=$WORKSPACE/target/classes\n保存应用。\nOK~现在就点击立即构建吧。\n 参考\n\n\nJenkins使用教程\n\n\nJenkins 集成 SonarQube Scanner\n\n\nJenkins集成SonarQube进行代码质量扫描\n\n\nsonarqube\n\n\nsonar-scanner扫描代码出错 SonarQube svn: E170001\n\n\nmax virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]\n\n\n解决：max file descriptors [65535] for elasticsearch process is too low\n\n\nsonar es can not run elasticsearch as root\n\n\nLinux下为Sonarqube安装中文插件\n\n\n","categories":["tutorials"],"tags":["CI/CD","linux"]},{"title":"Leetcode 2039. 网络空闲的时刻","url":"/posts/leetcode-2039.html","content":" Leetcode 2039. 网络空闲的时刻 \n 题目描述：\n给你一个有 n 个服务器的计算机网络，服务器编号为 0 到 n - 1 。同时给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示服务器 ui 和 vi 之间有一条信息线路，在 一秒 内它们之间可以传输 任意 数目的信息。再给你一个长度为 n 且下标从 0 开始的整数数组 patience 。\n题目保证所有服务器都是 相通 的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。\n编号为 0 的服务器是 主 服务器，其他服务器为 数据 服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按 最优 线路传输，也就是说每个信息都会以 最少时间 到达主服务器。主服务器会处理 所有 新到达的信息并 立即 按照每条信息来时的路线 反方向 发送回复信息。\n在 0 秒的开始，所有数据服务器都会发送各自需要处理的信息。从第 1 秒开始，每 一秒最 开始 时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）：\n\n如果还没收到任何回复信息，那么该服务器会周期性 重发 信息。数据服务器 i 每 patience[i] 秒都会重发一条信息，也就是说，数据服务器 i 在上一次发送信息给主服务器后的 patience[i] 秒 后 会重发一条信息给主服务器。\n否则，该数据服务器 不会重发 信息。\n\n当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 空闲 状态。\n请返回计算机网络变为 空闲 状态的 最早秒数 。\n示例 1：\n\n输入：edges = [[0,1],[1,2]], patience = [0,2,1]输出：8解释：0 秒最开始时，- 数据服务器 1 给主服务器发出信息（用 1A 表示）。- 数据服务器 2 给主服务器发出信息（用 2A 表示）。1 秒时，- 信息 1A 到达主服务器，主服务器立刻处理信息 1A 并发出 1A 的回复信息。- 数据服务器 1 还没收到任何回复。距离上次发出信息过去了 1 秒（1 &lt; patience[1] = 2），所以不会重发信息。- 数据服务器 2 还没收到任何回复。距离上次发出信息过去了 1 秒（1 == patience[2] = 1），所以它重发一条信息（用 2B 表示）。2 秒时，- 回复信息 1A 到达服务器 1 ，服务器 1 不会再重发信息。- 信息 2A 到达主服务器，主服务器立刻处理信息 2A 并发出 2A 的回复信息。- 服务器 2 重发一条信息（用 2C 表示）。...4 秒时，- 回复信息 2A 到达服务器 2 ，服务器 2 不会再重发信息。...7 秒时，回复信息 2D 到达服务器 2 。从第 8 秒开始，不再有任何信息在服务器之间传输，也不再有信息到达服务器。所以第 8 秒是网络变空闲的最早时刻。\n示例 2：\n\n输入：edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]输出：3解释：数据服务器 1 和 2 第 2 秒初收到回复信息。从第 3 秒开始，网络变空闲。\n提示：\n\nn == patience.length\n2 &lt;= n &lt;= 105\npatience[0] == 0\n对于 1 &lt;= i &lt; n ，满足 1 &lt;= patience[i] &lt;= 105\n1 &lt;= edges.length &lt;= min(105, n * (n - 1) / 2)\nedges[i].length == 2\n0 &lt;= ui, vi &lt; n\nui != vi\n不会有重边。\n每个服务器都直接或间接与别的服务器相连。\n\n 思路\n这里每个服务器最后变的空闲的时间都是相互独立的，所以我们算出每一个服务器接收最后一条消息的时间然后取最大的那一个就行了。\n要计算这个的时间，首先肯定是需要计算每个服务器到服务器0的最短距离，这里刚开始使用的是迪杰斯特拉，但是提交之后超时了，然后观察到所有服务器的距离都是1，所以直接BFS就可以得到距离。\n然后考虑怎么计算每个服务器的接受到最后一条消息的时间，接受最后一条消息的时间=发出最后一条消息的时间+2*服务器距离+1，所以最后需要计算的是最后一条消息发出的时间，如果距离距离×2&lt;=发送的间隔时间距离×2&lt;=发送的间隔时间距离×2&lt;=发送的间隔时间的话，那么最后一条消息就是第一条消息，否则：\n在停止发消息前，经历了2×距离−12×距离-12×距离−1的时间，再此期间则会发送⌊2×距离−1patience[i]⌋\\Big\\lfloor\\dfrac{2 \\times 距离- 1}{\\textit{patience}[i]}\\Big\\rfloor⌊patience[i]2×距离−1​⌋条消息，那么最后一条消息的时间就是：\n⌊2×距离−1patience[i]⌋×patience[i]\\Big\\lfloor\\dfrac{2 \\times 距离- 1}{patience[i]}\\Big\\rfloor \\times patience[i]\n⌊patience[i]2×距离−1​⌋×patience[i]\n 代码\nuse std::collections::VecDeque;impl Solution &#123;    pub fn network_becomes_idle(edges: Vec&lt;Vec&lt;i32&gt;&gt;, patience: Vec&lt;i32&gt;) -&gt; i32 &#123;        let num_point = patience.len();        let mut graph = vec![vec![]; num_point];        edges.iter().for_each(|x| &#123;            graph[x[0] as usize].push(x[1] as usize);            graph[x[1] as usize].push(x[0] as usize);        &#125;);        let mut distance = vec![num_point as i32; num_point];        let mut visited = vec![false; num_point];        visited[0] = true;        distance[0] = 0;        let mut queue = VecDeque::new();        queue.push_back(0);        while !queue.is_empty() &#123;            let cur = queue.pop_front().unwrap();            graph[cur].iter().for_each(|&amp;x| &#123;                if !visited[x] &#123;                    distance[x] = distance[cur] + 1;                    visited[x] = true;                    queue.push_back(x);                &#125;            &#125;)        &#125;        let mut ans = 0;        for i in 1..num_point &#123;            ans = ans.max(2 * distance[i] + 1 + if distance[i] * 2 &lt;= patience[i] &#123;                0            &#125; else &#123;                // 计算最后一次消息是什么时候发的                (2 * distance[i] - 1) / patience[i] * patience[i]            &#125;)        &#125;        ans    &#125;&#125;\n","categories":["algorithm"],"tags":["rust"]},{"title":"Leetcode 440. 字典序的第K小数字","url":"/posts/leetcode-440.html","content":" Leetcode 440. 字典序的第K小数字 \n 题目描述：\n给定整数 n 和 k，返回 [1, n] 中字典序第 k 小的数字。\n示例 1:\n输入: n = 13, k = 2输出: 10解释: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。\n示例 2:\n输入: n = 1, k = 1输出: 1\n提示:\n\n1 &lt;= k &lt;= n &lt;= 109\n\n 思路\n通过观察字典序的排列可以发现以下规律：\n\n以i+1开头的字典序肯定大于以i开头的\ni*10 =&gt; 字典序+1\ni+1 =&gt; 字典序+(i+1作为前缀的最小值 - i作为前缀的最小值)\n\n要找到在[1,n]中第k小的数字，我们肯定需要从以i作为前缀的开始数，首先需要计算出以i为前缀的个数，以i为前缀的个数即：以i+1为前缀的最小值-以i为前缀的最小值，且这些值都必须小于n。\n找到以i为前缀的个数count后，有两种情况：\n\nk&gt;count，说明以i为前缀的个数不够，还需要继续去找i+1的，k-=count，将i+1；\nk&lt;=count，则说明第k小的数字就是以i开头的，那么通过将i*10将字典序+1，然后重复上面的步骤就可以找出第k小字典序的数字了。\n\n 代码\nimpl Solution &#123;    pub fn find_kth_number(n: i32, k: i32) -&gt; i32 &#123;        let (mut k, mut cur, n) = ((k - 1) as i64, 1 as i64, n as i64);        while k &gt; 0 &#123;            let (mut count, mut first, mut last) = (0, cur, cur + 1);            while first &lt;= n &#123;                count += last.min(n + 1) - first;                first *= 10;                last *= 10;            &#125;            if count &lt;= k &#123;                cur += 1;                k -= count;            &#125; else &#123;                cur *= 10;                k -= 1;            &#125;        &#125;        cur as i32    &#125;&#125;\n","categories":["algorithm"],"tags":["rust"]},{"title":"Leetcode 798. 得分最高的最小轮调","url":"/posts/leetcode-798.html","content":" Leetcode 798. 得分最高的最小轮调 \n 题目描述：\n给你一个数组 nums，我们可以将它按一个非负整数 k 进行轮调，这样可以使数组变为 [nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]] 的形式。此后，任何值小于或等于其索引的项都可以记作一分。\n\n例如，数组为 nums = [2,4,1,3,0]，我们按 k = 2 进行轮调后，它将变成 [1,3,0,2,4]。这将记为 3 分，因为 1 &gt; 0 [不计分]、3 &gt; 1 [不计分]、0 &lt;= 2 [计 1 分]、2 &lt;= 3 [计 1 分]，4 &lt;= 4 [计 1 分]。\n\n在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调下标 k 。如果有多个答案，返回满足条件的最小的下标 k 。\n示例 1：\n输入：nums = [2,3,1,4,0]输出：3解释：下面列出了每个 k 的得分：k = 0,  nums = [2,3,1,4,0],    score 2k = 1,  nums = [3,1,4,0,2],    score 3k = 2,  nums = [1,4,0,2,3],    score 3k = 3,  nums = [4,0,2,3,1],    score 4k = 4,  nums = [0,2,3,1,4],    score 3所以我们应当选择 k = 3，得分最高。\n示例 2：\n输入：nums = [1,3,0,2,4]输出：0解释：nums 无论怎么变化总是有 3 分。所以我们将选择最小的 k，即 0。\n提示：\n\n1 &lt;= nums.length &lt;= 10^5\n0 &lt;= nums[i] &lt; nums.length\n\n 思路\n首先的思路当然是暴力求解，直接遍历K在0到nums.length这个范围内的所有得分，然后取得分最高的k值（若有多个取较小的k）即可，这样写思路很清晰代码也是比较简单的，但是这道题目的数据量是10510^5105，这样做的时间复杂度是O(N2)O(N^2)O(N2)，肯定是会超时的，所以需要去优化。\n首先我们将问题转化，先求出数组中每个值要取得得分时k的范围，假设下标为i，则需要：\nnumsi≤(i−k+n)%n0≤(i−k+n)%n≤n−1⇓k≤(i−numsi+n)k≤(i+n)%nk≥(i+1)%nnums_i \\leq (i-k+n)\\%n \\\\\n0 \\leq (i-k+n)\\%n \\leq n-1 \\\\\n\\Downarrow \\\\\nk \\leq (i-nums_i+n)\\\\%n \\\\\nk \\leq (i+n)\\%n \\\\\nk \\geq (i+1)\\%n\nnumsi​≤(i−k+n)%n0≤(i−k+n)%n≤n−1⇓k≤(i−numsi​+n)k≤(i+n)%nk≥(i+1)%n\n最终得到k的范围为：\nk∈{[(i+1)%n,(i−numsi+n)%n](i+1)%n≤(i−numsi+n)%n[0,(i−numsi+n)%n]∪[(i+1)%n,n−1](i+1)%n&gt;(i−numsi+n)%nk \\in \\left\\{\n\\begin{aligned}\n&amp;\\lbrack(i+1)\\%n,(i-nums_i+n)\\%n\\rbrack &amp;&amp; (i+1)\\%n \\leq (i-nums_i+n)\\%n \\\\\n&amp;\\lbrack0,(i-nums_i+n)\\%n\\rbrack \\cup \\lbrack(i+1)\\%n, n-1\\rbrack &amp;&amp; (i+1)\\%n &gt; (i-nums_i+n)\\%n \\\\\n\\end{aligned}\n\\right.\nk∈{​[(i+1)%n,(i−numsi​+n)%n][0,(i−numsi​+n)%n]∪[(i+1)%n,n−1]​​(i+1)%n≤(i−numsi​+n)%n(i+1)%n&gt;(i−numsi​+n)%n​\n我们就可以在O(n)O(n)O(n)的时间内求得每项可以得分的k的区间，这样问题就转换为了求k取多少时落在这些区间里最多（k取较小值）？\n然后我们可以这样来求解：先初始化一个长度为n，值为0的数组，然后对于上述的每个区间，将这个数组下标落在区间里的值加一，遍历完之后值最大的那个下标即为得分最高的k值。但是这样做的时间复杂度依然为O(n2)O(n^2)O(n2)，因为有n+个区间，每个区间的长度的数量级也为n，所以这里需要引入一个算法：差分数组\n 差分数组\n差分数组就是专门对数组的某个区间进行相同的操作，且时间复杂度为O(1)O(1)O(1)的一个算法，他的本质其实是前缀和的逆操作。步骤如下：\n首先求对应数组的差分数组：\na1,a2,...an−1,an⇒0,a2−a1,a3−a2−a1,...,an−an−1−an−2−...−a1a_1,a_2,...a_{n-1},a_n \\Rightarrow 0,a_2-a_1,a_3-a_2-a_1,...,a_n-a_{n-1}-a_{n-2}-...-a_1\na1​,a2​,...an−1​,an​⇒0,a2​−a1​,a3​−a2​−a1​,...,an​−an−1​−an−2​−...−a1​\n就本题来说初始的数组是[0;n][0;n][0;n]，那对应的差分数组仍为[0;n][0;n][0;n]；当我们需要对某个区间进行操作时只需要对端点处进行修改，如对[a,b][a,b][a,b]都+1则只需要\nnumsa+=1numsb+1−=1nums_a+=1  \\\\ \nnums_{b+1}-=1\nnumsa​+=1numsb+1​−=1\n即对左侧端点进行这个修改，对右侧的右边一个进行逆修改。\n然后是差分数组如何还原，进行前缀和运算就行了，因为前缀和是对数组前i项的累加，对左侧端点的修改就影响了后面的所有值，而对右侧端点的右边一个逆修改相当于消除了对之后的影响，于是就变成了对[a,b][a,b][a,b]的操作，且这里所有的操作都是O(1)O(1)O(1)的。\n然后使用这种算法再对上面的先初始化一个长度为n，值为0的数组，然后对于上述的每个区间，将这个数组下标落在区间里的值加一，遍历完之后值最大的那个下标即为得分最高的k值问题求解就很简单了。\n 代码\nimpl Solution &#123;    pub fn best_rotation(nums: Vec&lt;i32&gt;) -&gt; i32 &#123;        let n = nums.len();        let mut diff = vec![0; n+1];        for i in 0..nums.len() &#123;            let left = (i+1)%n;            let right = (i-(nums[i] as usize)+n)%n;            diff[left]+=1;            diff[right+1]-=1;            if left &gt; right &#123;                diff[0]+=1;                diff[n]-=1;            &#125;        &#125;        let mut ans = 0;        let mut tmp = 0;        let mut sum = 0;        for k in 0..n &#123;            sum += diff[k];            if sum &gt; tmp &#123;                tmp = sum;                ans = k;            &#125;        &#125;        ans as i32    &#125;&#125;\n","categories":["algorithm"],"tags":["rust"]},{"title":"Linux安装Java","url":"/posts/linux-install-java.html","content":" Java安装\n\n每次新（重置）系统需要用到Java的时候，都要去上网搜索安装一番，故记录在此。\n\n\n 获取url\n打开(https://www.oracle.com/java/technologies/javase-jdk8-downloads.html)选择Linux x64 Compressed Archive复制下载地址。\n 下载\nwget https://www.oracle.com/webapps/redirect/signon?nexturl=https://download.oracle.com/otn/java/jdk/8u251-b08/3d5a2bb8f8d4428bbe94aed7ec7ae784/jdk-8u251-linux-x64.tar.gz\n如果此处提示-bash:wget command not found\n则输入：yum -y install wget安装一下wget\n国外建议直接使用此链接https://data.lvss.tk/applications/jdk-8u251-linux-x64.tar.gz\n\n现在Oracle必须要登录才可以下载了。所以自寻下载链接。我这里选择先登录下载到本地在上传至Google drive下载。(阿里云5M小水管下到死,还是选择了直接ssh)\n\n 安装\n#创建安装目录mkdir /usr/local/java/#解压至安装目录tar -zxvf jdk-8u251-linux-x64.tar.gz -C /usr/local/java/\n 设置环境变量\nvim /etc/profile#添加export JAVA_HOME=/usr/local/java/jdk1.8.0_251export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH#使环境变量生效source /etc/profile#添加软连接（可选）ln -s /usr/local/java/jdk1.8.0_251/bin/java /usr/bin/java\n 验证是否成功\njava -versionjava version &quot;1.8.0_251&quot;Java(TM) SE Runtime Environment (build 1.8.0_251-b08)Java HotSpot(TM) 64-Bit Server VM (build 25.251-b08, mixed mode)\n Maven安装\n 下载Maven\n在下载页面选择需要的版本进行下载，这里我选择 apache-maven-3.6.3-bin.tar.gz，右键复制链接地址，然后：\nwget http://apache.communilink.net/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz\n 安装\ntar -zxvf apache-maven-3.6.3-bin.tar.gz -C /usr/local/java/\n 设置环境变量\nvim /etc/profile#添加export M2_HOME=/usr/local/java/apache-maven-3.6.3export PATH=$&#123;M2_HOME&#125;/bin:$PATH#使环境变量生效source /etc/profile\n 验证是否成功\nmvn -vApache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f)Maven home: /usr/local/java/apache-maven-3.6.3Java version: 1.8.0_251, vendor: Oracle Corporation, runtime: /usr/local/java/jdk1.8.0_251/jreDefault locale: zh_CN, platform encoding: UTF-8OS name: &quot;linux&quot;, version: &quot;3.10.0-1127.8.2.el7.x86_64&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;\n 更改默认的仓库位置与maven阿里云镜像：\n# 新建仓库文件夹mkdir /mnt/maven/repository# 备份默认的配置文件cd /mnt/maven/apache-maven-3.6.3/confcp settings.xml settings-backup.xmlvim settings.xml# 在settings标签中添加&lt;localRepository&gt;/mnt/maven/repository&lt;/localRepository&gt;# 添加mirrors子节点&lt;mirror&gt;  &lt;id&gt;aliyunmaven&lt;/id&gt;  &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;  &lt;name&gt;阿里云公共仓库&lt;/name&gt;  &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt;","categories":["tools"],"tags":["java","linux"]},{"title":"mac应用推荐","url":"/posts/mac-software.html","content":" 软件下载网站\n\nMacWk：https://macwk.com/\nXClient：https://xclient.info/\nAppKed：https://www.macbed.com/\n\n 工具类\n macOS小助手\n\nhttps://macwk.com/soft/macos-assistant-macwk\nmacOS小助手 是 MacWk.com 编写的一个应用程序，可以帮您快速的进行一些操作，比如禁用macOS的 Gatekeeper（守门员）、修复macOS 10.15 应用已损坏问题、修改mac截图保存位置、修改截图名称前缀、修改截图默认保存格式、禁用窗口截图的阴影、开启单应用模式、查看SIP状态、禁用 macOS 更新提示（关闭macOS设置图标的小红点）。\n\n Mos\n\nhttps://github.com/Caldis/Mos/\n一个用于在 macOS 上平滑你的鼠标滚动效果或单独设置滚动方向的小工具, 让你的滚轮爽如触控板\n\n Alfred4\n\nhttps://macwk.com/soft/alfred-4\nAlfred Powerpack 4 是一款本地搜索及快速启动工具，它可以帮你提高工作效率。alfred 4 可以快速的搜索本地应用、搜索本地文件、执行终端命令、翻译、文件管理、音乐控制等等！\n\n Mounty\n\nhttps://mounty.app/\nNTFS盘挂载\n\n Popclip\n\nhttps://macwk.com/soft/popclip\nPopClip 2020 破解版是一款划词工具。PopClip在Mac OS上对划词这个功能做了极大的增强，依附于各类小插件，我们能获得更多强大的功能来提升我们的操作效率。PopClip的核心其实在于扩展，上线快三年官方已经累计130多个常用的扩展。这还不包含Github上那些非官方的扩展们。\n\n Dozer\n\nhttps://github.com/Mortennn/Dozer\nDozer 是一款隐藏macOS菜单栏图标的应用，不同于 Bartender 和 Vanilla，Dozer 是免费、开源的。Dozer 操作方法也很简单，Dozer运行后在菜单栏会出现一个「‧」，点击它，然后会出现另外一个「‧」，按住 command 键拖曳「‧」调整到适当位置，然后点击一下「‧」就会隐藏第一个「‧」左边的图标，重新显示也只需要点击「‧」即可。具体的大家可以上手体验一下，很简单的。\n\n CheatSheet\n\nhttps://macwk.com/soft/cheatsheet\nCheatSheet 是一款可以快速查看mac应用快捷键的工具，你只需按住⌘键（command）几秒的时间，即可获得当前使用的应用程序所有的快捷组合列表。快捷键组合 列表窗口的右下角有个齿轮图标，可以设置呼出延时以及退出 CheatSheet。应用快捷键窗口中的名称是英文还是中文完全根据你使用的应用的语言决定。\n\n iTerm2\n\nhttps://iterm2.com/\niTerm2是Terminal的替代品，是iTerm的后继产品。 它适用于MacOS 10.14或更高版本的Mac。 iTerm2凭借您从未想过的功能将终端带入了现代时代。\n\n Fig\n\nhttps://fig.io/\nWith Fig, you can add autocomplete to any CLI tool or script using a declarative TypeScript schema.\n下载：https://fig.io/invite/?code=yuGMx8azXL\n\n ClashX\n\nhttps://github.com/yichengchen/clashX/releases\nA rule based proxy For Mac base on Clash.\n\n","categories":["tools"],"tags":["mac"]},{"title":"移除类dp问题","url":"/posts/remove-dp.html","content":" 移除类dp问题\n移除类dp问题和平常的dp问题不一样，因为平常的dp问题都是每次做出选择直接分解成子问题，但是移除类dp问题每次的选择会改变问题的状态，所以我们需要逆向思考，给状态的定义是每次最后的选择。\n 题目收集：\n 312. 戳气球\n有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。\n现在要求你戳破所有的气球。如果你戳破气球 i ，就可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。\n求所能获得硬币的最大数量。\n说明:\n\n你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。\n0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100\n\n示例:\n输入: [3,1,5,8]输出: 167 解释: nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167\n code\nclass Solution &#123;    public int maxCoins(int[] nums) &#123;        int len=nums.length;        if (len==0)return 0;        int[][] dp=new int[len][len];        for (int i = 0; i &lt; len; i++) &#123;            dp[i][i]=nums[i]*(i&gt;0?nums[i-1]:1)*(i+1&lt;len?nums[i+1]:1);        &#125;        for (int i = 1; i &lt; len; i++) &#123;            for (int j = 0; j &lt; len-i; j++) &#123;                for (int k = j; k &lt;= j+i; k++) &#123;                    dp[j][j+i]=Math.max(dp[j][j+i],nums[k]*(j&gt;0?nums[j-1]:1)*(j+i+1&lt;len?nums[j+i+1]:1)+(j&gt;k-1?0:dp[j][k-1])+(k+1&gt;j+i?0:dp[k+1][j+i]));                &#125;            &#125;        &#125;        return dp[0][len-1];    &#125;&#125;\n 546. 移除盒子\n给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。\n你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k &gt;= 1），这样一轮之后你将得到 k*k 个积分。\n当你将所有盒子都去掉之后，求你能获得的最大积分和。\n示例：\n输入：boxes = [1,3,2,2,2,3,4,3,1]输出：23解释：[1, 3, 2, 2, 2, 3, 4, 3, 1] ----&gt; [1, 3, 3, 4, 3, 1] (3*3=9 分) ----&gt; [1, 3, 3, 3, 1] (1*1=1 分) ----&gt; [1, 1] (3*3=9 分) ----&gt; [] (2*2=4 分)\n提示：\n\n1 &lt;= boxes.length &lt;= 100\n1 &lt;= boxes[i] &lt;= 100\n\n code\nclass Solution &#123;private:    int dp[100][100][100];public:    int removeBoxes(vector&lt;int&gt;&amp; boxes) &#123;        memset(dp,0,sizeof(dp));        return calculatePoints(boxes,0,boxes.size()-1,0);    &#125;    int calculatePoints(vector&lt;int&gt;&amp; boxes,int l,int r,int k)&#123;        if(l&gt;r)return 0;        if(dp[l][r][k]!=0)return dp[l][r][k];        while(r&gt;l&amp;&amp;boxes[r-1]==boxes[r])&#123;            r--;k++;        &#125;        dp[l][r][k]=calculatePoints(boxes,l,r-1,0)+(k+1)*(k+1);        for(int i=l;i&lt;r;++i)&#123;            if(boxes[i]==boxes[r])&#123;                dp[l][r][k]=max(dp[l][r][k],calculatePoints(boxes,l,i,k+1)+calculatePoints(boxes,i+1,r-1,0));            &#125;        &#125;        return dp[l][r][k];    &#125;&#125;;","categories":["algorithm"],"tags":["leetcode","dp"]},{"title":"VIM的简单使用","url":"/posts/vim-simple-used.html","content":" 简单的使用与配置\nvim主要有两个模式，编辑模式和命令模式\n命令行vim进入vim，i-&gt;insert模式，开始写作，esc退出到命令行模式，wq+filename进行保存。\n简单的配置如\nsyntax on #设置高亮set number #设置行号\n但这是暂时的配置，永久的配置写在~/.vimrc中。\n 一些快捷键\n命令模式下\nHJKL分别代表左下上右；\nw跳到下一个单词；\nb往回跳；\nCTRL+F往下翻页；\nCTRL+B往上翻页；\n行号+gg跳到指定行；\n行数+JK往上/下跳n行；\n/内容搜索内容，n跳到下一个，shift+n上一个；\ncc剪切一行，u进行撤销；\nyy复制；\nc行数c剪切指定行数；\np粘贴；\n 高级用法\nv进入visual模式，可以进行选择；\nCTRL+n自动补全（出现过的单词）；\n 插件\nvim plug进行插件管理。\n使用插件：在~/.vimrc中插入\ncall plug#begin()\t# plugin contentcall plug#end()\n:PlugInstall进行安装；\nCtrl+W切换左右窗口；\n删除插件：删除掉plugin content，然后:PlugClean；\n插件网站：vim awesome\n","categories":["tools"],"tags":["vim"]},{"title":"Rust中的crate和mod","url":"/posts/rust-crate-mod.html","content":" crate\n先看看官方的定义：\n\nA crate is a binary or library. The crate root is a source file that the Rust compiler starts from and makes up the root module of your crate (we’ll explain modules in depth in the “Defining Modules to Control Scope and Privacy” section). A package is one or more crates that provide a set of functionality. A package contains a Cargo.toml file that describes how to build those crates.\n\ncrate是rust中的最小编译单元，也就是说rust是按照一个一个的crate来编译的，每个crate都有一个入口文件，可以是下面三种情况：\n\nsrc下的main.rs文件\nsrc下的lib.rs文件（作为一个库）\nsrc/bin目录下的任意文件（包含main函数）\n\n mod\n而mod则更像是C++中的命名空间，以下几种情况都可以作为一个根mod：\n\n一个单独的文件为一个mod\n一个文件夹中包含mod.rs（其他的文件在mod.rs中被声明成子mod）\n文件夹同级的同名rs文件\n\nmod是可以嵌套的，它是一个树形结构，要想使用mod，则必须在某个入口文件中声明mod（其实rust就是以这个mod名称寻找文件进行了替换），而子mod则可以在它的父mod中进行声明，然后在要使用的地方有以下几种使用方式：\n\n在本文件中声明了mod，则可以直接使用这个mod；\n使用use关键字引入在其他文件中声明的mod；\n在src/bin目录下要使用同crate下的mod，则需要：在lib.rs中进行声明，然后使用这个crate的名称作为路径来use；\n在src/main.rs 可以使用上一种方式，但也可以去掉lib.rs而直接在本文件中来声明mod；\n所有的声明mod在其他文件中被use的话都需要pub导出；\nuse只是为了简化路径，也可以直接从根mod一直写下去而不使用use关键字。\n\n 示例\n文件：\n├─src│  │  lib.rs│  │  main.rs│  ││  ├─bin│  │      test.rs│  ││  └─test_mod│          child.rs│          mod.rs\n// test_mod/child.rspub fn test()&#123;    println!(&quot;hello,world&quot;)&#125;// test_mod/mod.rspub mod child; // 导出子mod// lib.rspub mod test_mod; // 将本crate声明为一个库// main.rsmod test_mod;fn main() &#123;    test_mod::child::test();&#125;// 或者直接：fn main() &#123;    crate_mod::test_mod::child::test()&#125;// bin/test.rsuse crate_mod::test_mod::child;fn main() &#123;    child::test()&#125;\n","categories":["learning"],"tags":["rust"]}]